{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/image_1.jpg","path":"images/image_1.jpg","modified":1,"renderable":0},{"_id":"source/images/welcome-image.jpg","path":"images/welcome-image.jpg","modified":1,"renderable":0},{"_id":"source/images/welcome_dark_1.jpg","path":"images/welcome_dark_1.jpg","modified":1,"renderable":0},{"_id":"source/images/welcome_light.jpg","path":"images/welcome_light.jpg","modified":1,"renderable":0},{"_id":"source/images/welcome_light_2.jpg","path":"images/welcome_light_2.jpg","modified":1,"renderable":0},{"_id":"source/images/about/about_1.jpg","path":"images/about/about_1.jpg","modified":1,"renderable":0},{"_id":"source/images/gugong/gugong_tag.jpg","path":"images/gugong/gugong_tag.jpg","modified":1,"renderable":0},{"_id":"source/images/gugong/gugong_tag_1.jpg","path":"images/gugong/gugong_tag_1.jpg","modified":1,"renderable":0},{"_id":"source/images/gugong/gugong_tag_3.jpg","path":"images/gugong/gugong_tag_3.jpg","modified":1,"renderable":0},{"_id":"source/images/kafka/consumer_groups.png","path":"images/kafka/consumer_groups.png","modified":1,"renderable":0},{"_id":"source/images/kafka/kafka-apis.png","path":"images/kafka/kafka-apis.png","modified":1,"renderable":0},{"_id":"source/images/kafka/kafka_01.png","path":"images/kafka/kafka_01.png","modified":1,"renderable":0},{"_id":"source/images/kafka/kafka_02.png","path":"images/kafka/kafka_02.png","modified":1,"renderable":0},{"_id":"source/images/kafka/kafka_3_1.png","path":"images/kafka/kafka_3_1.png","modified":1,"renderable":0},{"_id":"source/images/kafka/kafka_3_2.png","path":"images/kafka/kafka_3_2.png","modified":1,"renderable":0},{"_id":"source/images/kafka/kafka_tag.jpg","path":"images/kafka/kafka_tag.jpg","modified":1,"renderable":0},{"_id":"source/images/kafka/kafka_tag_1.jpg","path":"images/kafka/kafka_tag_1.jpg","modified":1,"renderable":0},{"_id":"source/images/kafka/log_anatomy.png","path":"images/kafka/log_anatomy.png","modified":1,"renderable":0},{"_id":"source/images/summer/xiatian_boy.jpg","path":"images/summer/xiatian_boy.jpg","modified":1,"renderable":0},{"_id":"source/images/summer/xiatian_girl.jpg","path":"images/summer/xiatian_girl.jpg","modified":1,"renderable":0},{"_id":"source/images/sql/sql_1.webp","path":"images/sql/sql_1.webp","modified":1,"renderable":0},{"_id":"source/images/tiger/two_tigers.jpg","path":"images/tiger/two_tigers.jpg","modified":1,"renderable":0},{"_id":"source/images/xiamen/welcome_dark_1.jpg","path":"images/xiamen/welcome_dark_1.jpg","modified":1,"renderable":0},{"_id":"source/images/xiamen/xiamen_tag.jpg","path":"images/xiamen/xiamen_tag.jpg","modified":1,"renderable":0},{"_id":"themes/zhaoo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/js/color-mode.js","path":"js/color-mode.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/favicon-144x144.png","path":"images/icons/favicon-144x144.png","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/apple-touch-icon.png","path":"images/icons/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/favicon-16x16.png","path":"images/icons/favicon-16x16.png","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/favicon-32x32.png","path":"images/icons/favicon-32x32.png","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/icons/zhaoo-logo.png","path":"images/icons/zhaoo-logo.png","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/cloud.png","path":"images/theme/cloud.png","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/image_1.jpg","path":"images/theme/image_1.jpg","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/loading.gif","path":"images/theme/loading.gif","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/post-image.jpg","path":"images/theme/post-image.jpg","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome-image.jpg","path":"images/theme/welcome-image.jpg","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome_dark_1.jpg","path":"images/theme/welcome_dark_1.jpg","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome_light_2.jpg","path":"images/theme/welcome_light_2.jpg","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/images/theme/welcome_light.jpg","path":"images/theme/welcome_light.jpg","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/daovoice/daovoice.js","path":"lib/daovoice/daovoice.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.css","path":"lib/fancybox/fancybox.css","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.js","path":"lib/fancybox/fancybox.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.css","path":"lib/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.js","path":"lib/gitalk/gitalk.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/highlight/a11y-dark.css","path":"lib/highlight/a11y-dark.css","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/highlight/highlight.js","path":"lib/highlight/highlight.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/jquery/jquery.js","path":"lib/jquery/jquery.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/lazyload/lazyload.js","path":"lib/lazyload/lazyload.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/pjax/pjax.js","path":"lib/pjax/pjax.js","modified":1,"renderable":1},{"_id":"themes/zhaoo/source/lib/qrcode/qrcode.js","path":"lib/qrcode/qrcode.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/galleries.json","hash":"5433e27f556a154c361aeab1fd8d25ba4d4a181e","modified":1626661525959},{"_id":"source/_data/local_images.json","hash":"7cad1121b29282559694909570e4ec40d710ccf9","modified":1626661525960},{"_id":"source/_posts/Kafka-2.md","hash":"dfd26bdbdd910a2a46e6b5b4e596af44ca11d2ea","modified":1626661525961},{"_id":"source/_posts/gugong_600years_diary.md","hash":"0e942c396f6857989efc73db3de39a6ba2c30425","modified":1626661720509},{"_id":"source/_posts/kafka-1.md","hash":"587eba7b9fa071fa942b1c5e0fde6381eb69c3ad","modified":1626661525964},{"_id":"source/_posts/kafka-3.md","hash":"dd05a95ff633475a0c6fd9ae26b7181211bf6f70","modified":1626661525965},{"_id":"source/_posts/hello-world.md","hash":"0c38c6eef7c50e6d99f091036f017c90bbce991d","modified":1626661718231},{"_id":"source/_posts/nacos-1.md","hash":"ed0786faf5a8c0f80de16d59ef60737560a0f22d","modified":1626661525966},{"_id":"source/_posts/two_tigers.md","hash":"9d5ea0230c2a18f3deabb808a54427df20978444","modified":1626661525972},{"_id":"source/_posts/sqlalchemy.md","hash":"c0f0490ad39fd00e395c40a4eb6ef089af77eab3","modified":1626665530820},{"_id":"source/about/index.md","hash":"2f74b719d70dab9730a5f7880237f5805d5f73c0","modified":1626661525978},{"_id":"source/categories/index.md","hash":"af4874056e604129c10a75683cf5cd37e2872ee9","modified":1626661525980},{"_id":"source/_posts/xiamen_diary.md","hash":"5ce23bf067e410b95408787fd24fc5bd310fb1a5","modified":1626661525977},{"_id":"source/galleries/index.md","hash":"c1792fd45d489e8f2c24ba5963cb112e2d18f0e8","modified":1626661525981},{"_id":"source/tags/index.md","hash":"ac6092f4765a6475992060e38742909f22799e4a","modified":1626661526308},{"_id":"source/galleries/厦门旅拍/index.md","hash":"20b81c24203e4a8e905977a5e50ba9d4cf0240a6","modified":1626661525983},{"_id":"source/galleries/记事/index.md","hash":"a05ad767d8c9df2909a37f6dc35b71c431304721","modified":1626661525984},{"_id":"source/images/kafka/consumer_groups.png","hash":"619c852e02b223e8af57e857d50759d1921b5d76","modified":1626661526099},{"_id":"source/images/kafka/kafka_tag.jpg","hash":"1ec42f906066b4e6d5e3e5cf74eb40504c66bd52","modified":1626661526109},{"_id":"source/images/kafka/kafka_tag_1.jpg","hash":"17945e2b35b97ca3b35f67517a49c1ebc0578522","modified":1626661526110},{"_id":"source/images/kafka/log_anatomy.png","hash":"7d387eec0de1ebfbcd98a3b0c87aa008b2dbe476","modified":1626661526111},{"_id":"source/images/kafka/kafka-apis.png","hash":"10e6cffc4e472a8f7f6cfdc189d2357fe5f5a779","modified":1626661526101},{"_id":"source/images/kafka/kafka_01.png","hash":"46d799f40b4548e4421cc276e622837c743bc837","modified":1626661526103},{"_id":"source/images/kafka/kafka_3_1.png","hash":"7f9a8822887fc05e0ac211fb5fd621fc5b945f24","modified":1626661526106},{"_id":"source/images/kafka/kafka_3_2.png","hash":"3ecc35d21588f93c3bcc95170ea9705459c15784","modified":1626661526108},{"_id":"source/images/kafka/kafka_02.png","hash":"7b3878c07c1a8701a06fb718f360e5de90b0f199","modified":1626661526104},{"_id":"source/images/sql/sql_1.webp","hash":"a3f90112ec908bdb72f6ac35c87e3983c09a89a0","modified":1626665496585},{"_id":"source/images/welcome-image.jpg","hash":"79e9c9e83a6d8a0bb627e645b770dd2628cd546e","modified":1626661526180},{"_id":"source/images/tiger/two_tigers.jpg","hash":"3b05f3d3af4cf63133c196d60411fc2112d14b16","modified":1626661526177},{"_id":"themes/zhaoo/LICENSE","hash":"212211b73f97708e0e243f95eb5adbcdaa1e685d","modified":1626661526311},{"_id":"themes/zhaoo/.gitignore","hash":"0d5c2fdbdc974f10150baa12e1fc171a34960ed8","modified":1626661526310},{"_id":"themes/zhaoo/README.md","hash":"2a372cad6bc8826e3d8ff280d377aaf8b9a5b381","modified":1626661526315},{"_id":"themes/zhaoo/README_EN.md","hash":"d0186295466e84a78e329773ba5efb9c42cbd0f3","modified":1626661526316},{"_id":"themes/zhaoo/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1626661526346},{"_id":"themes/zhaoo/languages/it.yml","hash":"2b5323867169b25e52009696680a12811b226c1e","modified":1626661526347},{"_id":"themes/zhaoo/languages/default.yml","hash":"cb49d6c405ac17b25c8822bc0050fabdf03ae535","modified":1626661526345},{"_id":"themes/zhaoo/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1626661526348},{"_id":"themes/zhaoo/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1626661526349},{"_id":"themes/zhaoo/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1626661526349},{"_id":"themes/zhaoo/languages/zh-CN.yml","hash":"a10d783759847b5c2fc460f3e99000588e76d7ea","modified":1626661526350},{"_id":"themes/zhaoo/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1626661526351},{"_id":"themes/zhaoo/layout/archive.ejs","hash":"590b744d722437cfb0b077108a6af58ec18becd2","modified":1626661526393},{"_id":"themes/zhaoo/layout/categories.ejs","hash":"89f358aa57ce6779c765fce13b42bc5851be8678","modified":1626661526394},{"_id":"themes/zhaoo/layout/category.ejs","hash":"87000e62516e7750ab4f6d878e8231ef78dc4850","modified":1626661526395},{"_id":"themes/zhaoo/layout/gallery.ejs","hash":"14cadaa9e073fb6980ab0f99a65db421b1236939","modified":1626661526401},{"_id":"themes/zhaoo/layout/galleries.ejs","hash":"b5059a7c664477dd848f98f6c81b80b72aeb724c","modified":1626661526400},{"_id":"themes/zhaoo/layout/index.ejs","hash":"2257045a7b6d593c4171f31152041c6ffd11c7a2","modified":1626661526402},{"_id":"themes/zhaoo/layout/layout.ejs","hash":"dfb36f81a780b516b4a97f6287162bfd0e1d5ae4","modified":1626661526403},{"_id":"themes/zhaoo/layout/post.ejs","hash":"92a6e048482fe2b1e86c954ee11b0b2b4c2539f2","modified":1626661526403},{"_id":"themes/zhaoo/layout/pure.ejs","hash":"0c1a5ae68fd69bc8d19f5bb0af1afe3656d1cd5d","modified":1626661526404},{"_id":"themes/zhaoo/layout/tag.ejs","hash":"238c2e2077f01f4fe252ad99db4891a632904cee","modified":1626661526405},{"_id":"themes/zhaoo/layout/tags.ejs","hash":"40efc30cbc712282b560491ea537e443a10efa8e","modified":1626661526409},{"_id":"themes/zhaoo/scripts/caption.js","hash":"ecd6bcdf43bcf2712dbf66956cb0d900bb381a27","modified":1626661526442},{"_id":"themes/zhaoo/scripts/carrier.js","hash":"f0297ca112ffdfed6147e869e4b37ca5d96f0e1b","modified":1626661526443},{"_id":"themes/zhaoo/scripts/entry.js","hash":"030235848bb787c48bf7078a7c79c9d4fd58722d","modified":1626661526444},{"_id":"themes/zhaoo/scripts/lazyload.js","hash":"2f6f0e3cfd29e676efe8dc76f062d8cef6569820","modified":1626661526445},{"_id":"themes/zhaoo/scripts/merge-config.js","hash":"c87ed49ddd95a900b4e105eafbe8b34cb36ab8d0","modified":1626661526446},{"_id":"themes/zhaoo/scripts/title.js","hash":"d19f444206ea11aff52b5f55756ba082f63b7e6a","modified":1626661526453},{"_id":"themes/zhaoo/layout/_partial/head.ejs","hash":"dd41a812b037cf2078ab49fd02cdf89994cb3014","modified":1626661526364},{"_id":"themes/zhaoo/layout/_partial/script.ejs","hash":"6f29c9b5c9a3de0ac1f8b90b113f69d9992f8d69","modified":1626661526390},{"_id":"themes/zhaoo/scripts/post-image.js","hash":"225f3f153d39f413cad75bb43bd3e2d85cc2d4d2","modified":1626661526452},{"_id":"themes/zhaoo/source/css/style.styl","hash":"7fa02eac24fa73babaf01ed0a5a17412e9e4ed91","modified":1626661526514},{"_id":"themes/zhaoo/source/js/color-mode.js","hash":"cda2e5d23db3aa3c5dd3f26ce470e7743ba2ed41","modified":1626661526661},{"_id":"themes/zhaoo/_config.yml","hash":"0bde2a14d89c5d0c17e63cc69a7460e73a9b8e35","modified":1626661526326},{"_id":"themes/zhaoo/source/js/utils.js","hash":"3f698957840955e901613c1717e57d173ed9f6e8","modified":1626661526663},{"_id":"themes/zhaoo/source/js/script.js","hash":"de7547b1899313b105a7f2eaec721e09b0132a22","modified":1626661526662},{"_id":"themes/zhaoo/_example/source/_data/galleries.json","hash":"b74e764d64c6a0f1fe88e6ff7387e679da3c2efb","modified":1626661526328},{"_id":"themes/zhaoo/_example/source/about/index.md","hash":"239dc6fa67a26de7aa9cac61cfc69fe967f94384","modified":1626661526333},{"_id":"themes/zhaoo/_example/source/_posts/hexo-theme-zhaoo-doc.md","hash":"e31c483de88963ebc7c4ef5f5e0c9e1c0446aa3b","modified":1626661526330},{"_id":"themes/zhaoo/_example/source/categories/index.md","hash":"ac97d61802f6121730ef0df581df44f077b39825","modified":1626661526335},{"_id":"themes/zhaoo/_example/source/_posts/hexo-theme-zhaoo.md","hash":"3c3023a7cee4702f56306c995048314e961cbabb","modified":1626661526332},{"_id":"themes/zhaoo/_example/source/galleries/index.md","hash":"e762f0065f939e26517997011351e861c1c892a5","modified":1626661526341},{"_id":"themes/zhaoo/_example/source/tags/index.md","hash":"ac6092f4765a6475992060e38742909f22799e4a","modified":1626661526344},{"_id":"themes/zhaoo/layout/_partial/comments/gitalk.ejs","hash":"a1845bca3f412dadcad072dfe60eb3911f833559","modified":1626661526354},{"_id":"themes/zhaoo/layout/_partial/comments/changyan.ejs","hash":"3452beb86058943cb711719a7651987807787487","modified":1626661526353},{"_id":"themes/zhaoo/layout/_partial/comments/valine.ejs","hash":"5e6287660dfb296cbe63c85713533939e4a2fdde","modified":1626661526355},{"_id":"themes/zhaoo/_example/source/_data/local_images.json","hash":"7cad1121b29282559694909570e4ec40d710ccf9","modified":1626661526329},{"_id":"themes/zhaoo/layout/_partial/components/footer.ejs","hash":"1eaf1655bae68138d21e324a83028b635f24efdf","modified":1626661526357},{"_id":"themes/zhaoo/layout/_partial/components/fab.ejs","hash":"bfa085d125e9e4c85390c51216a018a303bd0569","modified":1626661526356},{"_id":"themes/zhaoo/layout/_partial/components/header.ejs","hash":"79dc1dd669228f017f853acda4a8e51c6a631db4","modified":1626661526358},{"_id":"themes/zhaoo/layout/_partial/components/loading.ejs","hash":"81680b42a796d4d500eda9c5d87d8e80e4b938b2","modified":1626661526359},{"_id":"themes/zhaoo/layout/_partial/components/menu.ejs","hash":"8bfbdc6c78970b7c6fd946b9932cb0e961178169","modified":1626661526360},{"_id":"themes/zhaoo/layout/_partial/components/navbar.ejs","hash":"67c257328ed5ecc2e8131ca67d71b2b300009254","modified":1626661526360},{"_id":"themes/zhaoo/layout/_partial/components/paginator.ejs","hash":"b9810cd5ad253a4ce2050f571fc0bb8e8b0f2580","modified":1626661526361},{"_id":"themes/zhaoo/layout/_partial/components/search.ejs","hash":"bc270f445892aaea460b057107d8ba2fc89635ae","modified":1626661526363},{"_id":"themes/zhaoo/layout/_partial/components/scrollbar.ejs","hash":"5abc155f13e03bd1203d485a24658d73a27b246a","modified":1626661526362},{"_id":"themes/zhaoo/layout/_partial/index/item.ejs","hash":"3dccb148f5205719643bddebb7dbb5d11a45a187","modified":1626661526365},{"_id":"themes/zhaoo/layout/_partial/index/post.ejs","hash":"83a715a96a0091aaf15919b7bc4df67b96827144","modified":1626661526366},{"_id":"themes/zhaoo/layout/_partial/plugins/analytics.ejs","hash":"a512bca486f0a1b4dbcc19d50cb02f6e211055df","modified":1626661526368},{"_id":"themes/zhaoo/layout/_partial/index/preview.ejs","hash":"a271191f768401206ca8a71b13d8e06e6f773538","modified":1626661526367},{"_id":"themes/zhaoo/layout/_partial/plugins/seo.ejs","hash":"f9522a8b323b97b3c224dbfab590a5fd1812dbcb","modified":1626661526370},{"_id":"themes/zhaoo/layout/_partial/plugins/visitors.ejs","hash":"df441c30f5d4168fadc5d70f71da5695295d86ca","modified":1626661526371},{"_id":"themes/zhaoo/layout/_partial/post/article.ejs","hash":"d886a30975916d8f1555674f1b2441ed25579bbb","modified":1626661526372},{"_id":"themes/zhaoo/layout/_partial/post/comments.ejs","hash":"23ee3e0e52d4813d07a3fa1cf23b05195823a7cc","modified":1626661526382},{"_id":"themes/zhaoo/layout/_partial/post/copyright.ejs","hash":"4d2a20ef75c244a34456b40d47bdcdf9cc8abdc9","modified":1626661526384},{"_id":"themes/zhaoo/layout/_partial/plugins/daovoice.ejs","hash":"5f549e08701281dcbc215d8fcd727474c81e906b","modified":1626661526369},{"_id":"themes/zhaoo/layout/_partial/post/donate.ejs","hash":"5c3bc6f4aa594bae63a9c7a21b5e812292c6e63a","modified":1626661526385},{"_id":"themes/zhaoo/layout/_partial/post/head.ejs","hash":"60ef5cf812d7735a1c46263fb963b7fc23c80d2b","modified":1626661526386},{"_id":"themes/zhaoo/layout/_partial/post/nav.ejs","hash":"be8910cac98be268aa96f9f7f6c44aa2145d706f","modified":1626661526387},{"_id":"themes/zhaoo/layout/_partial/post/tag.ejs","hash":"9a5276ffdccf9c808adeb31407cc7da0de5e62df","modified":1626661526388},{"_id":"themes/zhaoo/layout/_partial/post/toc.ejs","hash":"ab99befc8c22ea8c25dbaae606f0bd59f447637e","modified":1626661526389},{"_id":"themes/zhaoo/source/css/_base/color-mode.styl","hash":"2b1682c1ed7c5e89a321555512d5b085455fc682","modified":1626661526455},{"_id":"themes/zhaoo/source/css/_base/zui.styl","hash":"407360c471a60b0732004e6bd4b34a21ec83ede0","modified":1626661526462},{"_id":"themes/zhaoo/source/css/_base/reset.styl","hash":"43e356911edcf4097a9023c349fb777a161601b3","modified":1626661526457},{"_id":"themes/zhaoo/source/css/_components/common.styl","hash":"a4e466d3dbf4863b4f243b5e67ae221971bfa989","modified":1626661526467},{"_id":"themes/zhaoo/source/css/_components/fab.styl","hash":"2f4fec084a9b9ad4e6ce5686a28d626d5197696e","modified":1626661526468},{"_id":"themes/zhaoo/source/css/_components/header.styl","hash":"c4f486ff965a21546b0e1497aad1ed1c75d5b089","modified":1626661526473},{"_id":"themes/zhaoo/source/css/_components/menu.styl","hash":"739b064df0921d113f269544b6144a425094c3ed","modified":1626661526475},{"_id":"themes/zhaoo/source/css/_components/navbar.styl","hash":"1b34e70cb0f958d08c7d31dbd5830ae89fb2d0bc","modified":1626661526476},{"_id":"themes/zhaoo/source/css/_components/paginator.styl","hash":"579c1a6aec3c46b2733b1687161ffbdbaaec6b54","modified":1626661526477},{"_id":"themes/zhaoo/source/css/_components/preview.styl","hash":"3781fb0d8c9bbbee132dad555bacf804e9702960","modified":1626661526478},{"_id":"themes/zhaoo/source/css/_components/scrollbar.styl","hash":"98df51db0c99897a4c58bbdcf8954c4cf148a607","modified":1626661526479},{"_id":"themes/zhaoo/source/css/_components/search.styl","hash":"ac65010dda7d79e002f6702602a7de4b873aec4e","modified":1626661526479},{"_id":"themes/zhaoo/source/css/_pages/pages.styl","hash":"f561158053bd9f84e07737494626f141ae3a28b2","modified":1626661526512},{"_id":"themes/zhaoo/source/css/_components/footer.styl","hash":"ebd937d9bcc9942b3f59fcc330117be9909c3ae3","modified":1626661526472},{"_id":"themes/zhaoo/source/css/_variables/variables.styl","hash":"bca8f684195f1c052b9b5546b4b6ec558f54d4bf","modified":1626661526513},{"_id":"themes/zhaoo/source/images/icons/favicon-144x144.png","hash":"e54f440ff564f1235f9c399e2cd435dd502ceb84","modified":1626661526517},{"_id":"themes/zhaoo/source/images/icons/apple-touch-icon.png","hash":"c1d16404a57db24e985204e7b2b97fa45d5fea0b","modified":1626661526516},{"_id":"themes/zhaoo/source/images/icons/favicon-16x16.png","hash":"86cc7a07ccf09deff3de7b0ef2f82daa282a8b8e","modified":1626661526519},{"_id":"themes/zhaoo/source/images/icons/favicon-32x32.png","hash":"7b095984bd7d07e10fa9b0df8347a933eba8537c","modified":1626661526520},{"_id":"themes/zhaoo/source/images/icons/zhaoo-logo.png","hash":"50f9f5de4207847bba6aecc4c21d21d79f0001fb","modified":1626661526521},{"_id":"themes/zhaoo/source/images/theme/loading.gif","hash":"db91090dd60098086993953f88c37a332eea70d7","modified":1626661526549},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1626661526670},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.css","hash":"2300f2218690a06dce07fe7eeb31bcbf014907f7","modified":1626661526673},{"_id":"themes/zhaoo/source/lib/highlight/highlight.js","hash":"976504107e1449a98ede49e0b06480a6818ae39e","modified":1626661526678},{"_id":"themes/zhaoo/source/lib/highlight/a11y-dark.css","hash":"9f0c935216015dd88251a6c366bdd00abfe65982","modified":1626661526677},{"_id":"themes/zhaoo/source/lib/lazyload/lazyload.js","hash":"322b05c0beb539459214aab2d4cec386ccc2c294","modified":1626661526691},{"_id":"themes/zhaoo/source/lib/pjax/pjax.js","hash":"a1e9fe6ad32e947451584531db3fcb0924354a96","modified":1626661526693},{"_id":"themes/zhaoo/source/lib/qrcode/qrcode.js","hash":"749139770957126aa0cd39a89e974f11d1dbba5d","modified":1626661526694},{"_id":"themes/zhaoo/_example/source/galleries/colorful/index.md","hash":"1d62f01d2b06bdd51cbac17bb69b031a7205317b","modified":1626661526339},{"_id":"themes/zhaoo/_example/source/galleries/深圳日记/index.md","hash":"0cac4cff71e988970dce718b5c78e023f066dd52","modified":1626661526342},{"_id":"themes/zhaoo/_example/source/galleries/记事/index.md","hash":"a05ad767d8c9df2909a37f6dc35b71c431304721","modified":1626661526343},{"_id":"themes/zhaoo/source/css/_pages/_archive/archive.styl","hash":"6f50017eb617c2b9eb400eef810405032955d496","modified":1626661526481},{"_id":"themes/zhaoo/source/css/_pages/_category/categories.styl","hash":"ce06edbffa932fe31b39f0aec6b07524fd084159","modified":1626661526483},{"_id":"themes/zhaoo/source/css/_pages/_index/index.styl","hash":"23c1826768061f2380cc9890321855b87bc1ca60","modified":1626661526505},{"_id":"themes/zhaoo/source/css/_pages/_post/article.styl","hash":"82c8048b7d994ca710a64583332757c4c79efc1b","modified":1626661526506},{"_id":"themes/zhaoo/source/css/_pages/_gallery/gallery.styl","hash":"78da3b485274d665f569d8412932446ce2867a28","modified":1626661526498},{"_id":"themes/zhaoo/source/css/_pages/_gallery/galleries.styl","hash":"d1ccfe444eec69056ec0cd9431c5c04002283a1f","modified":1626661526492},{"_id":"themes/zhaoo/source/css/_pages/_post/toc.styl","hash":"c57a90d296185225ff21df30f0a4a361072a840b","modified":1626661526509},{"_id":"themes/zhaoo/source/css/_pages/_tag/tags.styl","hash":"09232e1a81af46cba6401cf0817e1d64c2f7cb8e","modified":1626661526511},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.js","hash":"eef46b6fb2e460838cd7328a6e13ecda0cb1e194","modified":1626661526672},{"_id":"themes/zhaoo/source/lib/jquery/jquery.js","hash":"b15f7cfa79519756dff1ad22553fd0ed09024343","modified":1626661526680},{"_id":"themes/zhaoo/source/images/theme/cloud.png","hash":"fdf44a91026ad999dca2f0a42213aabebd783c98","modified":1626661526523},{"_id":"themes/zhaoo/source/images/theme/post-image.jpg","hash":"7fb1947508a411177829cedac8d5922671cac2b0","modified":1626661526551},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.js","hash":"668a325f964a57aace92f46de8ee709768ccd251","modified":1626661526675},{"_id":"themes/zhaoo/screenshots/menu.png","hash":"0f4220734a52953636a5273d64a03c8b01ec6098","modified":1626661526433},{"_id":"themes/zhaoo/source/images/theme/welcome-image.jpg","hash":"79e9c9e83a6d8a0bb627e645b770dd2628cd546e","modified":1626661526555},{"_id":"themes/zhaoo/screenshots/galleries.png","hash":"8ba5a26c7932d5ef456cc799bbc00c5f468e54cc","modified":1626661526421},{"_id":"themes/zhaoo/source/lib/daovoice/daovoice.js","hash":"0a666f89f583159c89d3ba512e5cacbe0633f28f","modified":1626661526669},{"_id":"themes/zhaoo/screenshots/article.png","hash":"74706d28c479a20f77c1bd4454879cabf8784ca6","modified":1626661526416},{"_id":"source/images/about/about_1.jpg","hash":"4aaf146d836051c0e62d21e51d1335a8053713a1","modified":1626661525991},{"_id":"themes/zhaoo/screenshots/index.png","hash":"a95df16106c813b92f14071bac3d38bc53a1bc00","modified":1626661526430},{"_id":"themes/zhaoo/screenshots/preview.png","hash":"2b4271a275b9ff8318d00ab04504a109ec931fe7","modified":1626661526440},{"_id":"source/images/xiamen/xiamen_tag.jpg","hash":"67b8f48bfa3c141fce9bff03aa4ac563943755ab","modified":1626661526306},{"_id":"source/images/gugong/gugong_tag.jpg","hash":"caf73a4fbb2d47b03e3610b179fc023f7e3af425","modified":1626661526002},{"_id":"source/images/welcome_light_2.jpg","hash":"b9e4f79b5c027af4e0bfc3388ab6121a577f7b11","modified":1626661526281},{"_id":"themes/zhaoo/source/images/theme/welcome_light_2.jpg","hash":"b9e4f79b5c027af4e0bfc3388ab6121a577f7b11","modified":1626661526658},{"_id":"source/images/welcome_dark_1.jpg","hash":"65303adb45f666ec9ed84279e23decaf7d54fffa","modified":1626661526197},{"_id":"source/images/xiamen/welcome_dark_1.jpg","hash":"65303adb45f666ec9ed84279e23decaf7d54fffa","modified":1626661526298},{"_id":"source/images/gugong/gugong_tag_3.jpg","hash":"c549b1d3947aebb335c106ebff322a47f788c7d6","modified":1626661526073},{"_id":"themes/zhaoo/source/images/theme/welcome_dark_1.jpg","hash":"65303adb45f666ec9ed84279e23decaf7d54fffa","modified":1626661526571},{"_id":"source/images/image_1.jpg","hash":"8bd0c620db0fe61aaa6e63ce4bf296ef0afdbd51","modified":1626661526097},{"_id":"source/images/summer/xiatian_girl.jpg","hash":"675162699dfe02da7b483039901ea9641116552e","modified":1626661526171},{"_id":"source/images/summer/xiatian_boy.jpg","hash":"e81142dc2568a62fb0411a390aefcb9e0401d71b","modified":1626661526134},{"_id":"themes/zhaoo/source/images/theme/image_1.jpg","hash":"8bd0c620db0fe61aaa6e63ce4bf296ef0afdbd51","modified":1626661526546},{"_id":"source/images/gugong/gugong_tag_1.jpg","hash":"dc80a3ac78b45bf7ce4ea00ffb6112845436aad6","modified":1626661526055},{"_id":"source/images/welcome_light.jpg","hash":"1300716567353c76b7efd6a2b6099b5184ecc968","modified":1626661526261},{"_id":"themes/zhaoo/source/images/theme/welcome_light.jpg","hash":"1300716567353c76b7efd6a2b6099b5184ecc968","modified":1626661526634}],"Category":[{"name":"技术","_id":"ckra348wj0004zwvaaaaehfnh"},{"name":"日记","_id":"ckra348wo000czwva2xjz6nwr"}],"Data":[{"_id":"galleries","data":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}]},{"_id":"local_images","data":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}],"Page":[{"title":"It's me","date":"2021-07-02T04:45:42.000Z","image":"/images/about/about_1.jpg","copyright":false,"_content":"","source":"about/index.md","raw":"---\ntitle: It's me\ndate: 2021-07-02 12:45:42\nimage: /images/about/about_1.jpg\ncopyright: false\n---\n","updated":"2021-07-19T02:25:25.978Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckra348w90000zwvagl0w9lqq","content":"","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"","more":""},{"title":"categories","date":"2021-07-02T04:38:44.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-07-02 12:38:44\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2021-07-19T02:25:25.980Z","path":"categories/index.html","comments":1,"_id":"ckra348wg0002zwva5tym5do8","content":"","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"","more":""},{"title":"galleries","date":"2021-06-29T04:39:40.000Z","layout":"galleries","_content":"","source":"galleries/index.md","raw":"---\ntitle: galleries\ndate: 2021-06-29 12:39:40\nlayout: \"galleries\"\n---\n","updated":"2021-07-19T02:25:25.981Z","path":"galleries/index.html","comments":1,"_id":"ckra348wk0006zwvaf2rbe8pw","content":"","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"","more":""},{"title":"标签","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\nlayout: \"tags\"\n---\n","date":"2021-07-19T02:25:26.308Z","updated":"2021-07-19T02:25:26.308Z","path":"tags/index.html","comments":1,"_id":"ckra348wm0008zwva77pc82bp","content":"","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"","more":""},{"title":"厦门旅拍","layout":"gallery","_content":"","source":"galleries/厦门旅拍/index.md","raw":"---\ntitle: 厦门旅拍\nlayout: \"gallery\"\n---","date":"2021-07-19T02:25:25.983Z","updated":"2021-07-19T02:25:25.983Z","path":"galleries/厦门旅拍/index.html","comments":1,"_id":"ckra348wn000azwva04kk13tg","content":"","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"","more":""},{"title":"记事","layout":"gallery","_content":"","source":"galleries/记事/index.md","raw":"---\ntitle: 记事\nlayout: \"gallery\"\n---","date":"2021-07-19T02:25:25.984Z","updated":"2021-07-19T02:25:25.984Z","path":"galleries/记事/index.html","comments":1,"_id":"ckra348wp000ezwva7jrn3sv5","content":"","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"","more":""}],"Post":[{"title":"Kafka(二)","date":"2021-07-04T12:58:15.000Z","keywords":"Kafka,kafka","top":49,"image":"/images/kafka/kafka_tag_1.jpg","_content":"\nKafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。\n<!--more-->\n\n# **Apache Kafka 是一个分布式流处理平台。**\n\n## 1.0 Kafka结构\n\nKafka集群包含若干Producer，若干broker（broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将信息发布到broker，Consumer使用pull模式从broker订阅并消费消息。\n\n![](/images/kafka/kafka_02.png)\n\n## 2.0 Producer消息\n\nProducer发送消息到broker时，会根据Partition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就视线里负载均衡。如果一个Topic对应一个文件，那这个文件所在的机器I/O就会变成这个Topic的性能瓶颈，但有了Partition后，不同的消息可以并行写入不同broker的不同的Partition里，可以极大地提高吞吐率。\n\n## 3.0 Topics和Partition\n\nTopic在逻辑上可以被认为是一个queue，每条消费都必须指定他的Topic，可以简单理解为必须指名把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。（顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。\n\n## 4.0 Consumer Group\n\n![](/images/kafka/consumer_groups.png)\n\n使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group 可同时消费这一消息。\n\n这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Comsumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不是需要多次发送消息到不同的Topic.\n\n\n## 5.0 push and pull\n\nKafka作为一个消息系统遵循了传统的方式，选择又Producer向broker push消息并由Consumer从broker pull消息。\n\npush模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成Consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据Consumer的消费能力以适当的速率消费消息。\n\nKafka更适合pull模式，pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。","source":"_posts/Kafka-2.md","raw":"---\ntitle: Kafka(二)\ndate: 2021-07-04 20:58:15\ntags: Kafka\ncategories: 技术\nkeywords: Kafka,kafka\ntop: 49\nimage: /images/kafka/kafka_tag_1.jpg\n---\n\nKafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。\n<!--more-->\n\n# **Apache Kafka 是一个分布式流处理平台。**\n\n## 1.0 Kafka结构\n\nKafka集群包含若干Producer，若干broker（broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将信息发布到broker，Consumer使用pull模式从broker订阅并消费消息。\n\n![](/images/kafka/kafka_02.png)\n\n## 2.0 Producer消息\n\nProducer发送消息到broker时，会根据Partition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就视线里负载均衡。如果一个Topic对应一个文件，那这个文件所在的机器I/O就会变成这个Topic的性能瓶颈，但有了Partition后，不同的消息可以并行写入不同broker的不同的Partition里，可以极大地提高吞吐率。\n\n## 3.0 Topics和Partition\n\nTopic在逻辑上可以被认为是一个queue，每条消费都必须指定他的Topic，可以简单理解为必须指名把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。（顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。\n\n## 4.0 Consumer Group\n\n![](/images/kafka/consumer_groups.png)\n\n使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group 可同时消费这一消息。\n\n这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Comsumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不是需要多次发送消息到不同的Topic.\n\n\n## 5.0 push and pull\n\nKafka作为一个消息系统遵循了传统的方式，选择又Producer向broker push消息并由Consumer从broker pull消息。\n\npush模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成Consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据Consumer的消费能力以适当的速率消费消息。\n\nKafka更适合pull模式，pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。","slug":"Kafka-2","published":1,"updated":"2021-07-19T02:25:25.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra348wd0001zwva4dnj4lkz","content":"<p>Kafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Apache-Kafka-是一个分布式流处理平台。\"><a href=\"#Apache-Kafka-是一个分布式流处理平台。\" class=\"headerlink\" title=\"Apache Kafka 是一个分布式流处理平台。\"></a><strong>Apache Kafka 是一个分布式流处理平台。</strong></h1><h2 id=\"1-0-Kafka结构\"><a href=\"#1-0-Kafka结构\" class=\"headerlink\" title=\"1.0 Kafka结构\"></a>1.0 Kafka结构</h2><p>Kafka集群包含若干Producer，若干broker（broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将信息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>\n<p><img src=\"/images/kafka/kafka_02.png\"></p>\n<h2 id=\"2-0-Producer消息\"><a href=\"#2-0-Producer消息\" class=\"headerlink\" title=\"2.0 Producer消息\"></a>2.0 Producer消息</h2><p>Producer发送消息到broker时，会根据Partition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就视线里负载均衡。如果一个Topic对应一个文件，那这个文件所在的机器I/O就会变成这个Topic的性能瓶颈，但有了Partition后，不同的消息可以并行写入不同broker的不同的Partition里，可以极大地提高吞吐率。</p>\n<h2 id=\"3-0-Topics和Partition\"><a href=\"#3-0-Topics和Partition\" class=\"headerlink\" title=\"3.0 Topics和Partition\"></a>3.0 Topics和Partition</h2><p>Topic在逻辑上可以被认为是一个queue，每条消费都必须指定他的Topic，可以简单理解为必须指名把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。（顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</p>\n<h2 id=\"4-0-Consumer-Group\"><a href=\"#4-0-Consumer-Group\" class=\"headerlink\" title=\"4.0 Consumer Group\"></a>4.0 Consumer Group</h2><p><img src=\"/images/kafka/consumer_groups.png\"></p>\n<p>使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group 可同时消费这一消息。</p>\n<p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Comsumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不是需要多次发送消息到不同的Topic.</p>\n<h2 id=\"5-0-push-and-pull\"><a href=\"#5-0-push-and-pull\" class=\"headerlink\" title=\"5.0 push and pull\"></a>5.0 push and pull</h2><p>Kafka作为一个消息系统遵循了传统的方式，选择又Producer向broker push消息并由Consumer从broker pull消息。</p>\n<p>push模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成Consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据Consumer的消费能力以适当的速率消费消息。</p>\n<p>Kafka更适合pull模式，pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p>\n","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"<p>Kafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。</p>","more":"<h1 id=\"Apache-Kafka-是一个分布式流处理平台。\"><a href=\"#Apache-Kafka-是一个分布式流处理平台。\" class=\"headerlink\" title=\"Apache Kafka 是一个分布式流处理平台。\"></a><strong>Apache Kafka 是一个分布式流处理平台。</strong></h1><h2 id=\"1-0-Kafka结构\"><a href=\"#1-0-Kafka结构\" class=\"headerlink\" title=\"1.0 Kafka结构\"></a>1.0 Kafka结构</h2><p>Kafka集群包含若干Producer，若干broker（broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将信息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>\n<p><img src=\"/images/kafka/kafka_02.png\"></p>\n<h2 id=\"2-0-Producer消息\"><a href=\"#2-0-Producer消息\" class=\"headerlink\" title=\"2.0 Producer消息\"></a>2.0 Producer消息</h2><p>Producer发送消息到broker时，会根据Partition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就视线里负载均衡。如果一个Topic对应一个文件，那这个文件所在的机器I/O就会变成这个Topic的性能瓶颈，但有了Partition后，不同的消息可以并行写入不同broker的不同的Partition里，可以极大地提高吞吐率。</p>\n<h2 id=\"3-0-Topics和Partition\"><a href=\"#3-0-Topics和Partition\" class=\"headerlink\" title=\"3.0 Topics和Partition\"></a>3.0 Topics和Partition</h2><p>Topic在逻辑上可以被认为是一个queue，每条消费都必须指定他的Topic，可以简单理解为必须指名把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。（顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</p>\n<h2 id=\"4-0-Consumer-Group\"><a href=\"#4-0-Consumer-Group\" class=\"headerlink\" title=\"4.0 Consumer Group\"></a>4.0 Consumer Group</h2><p><img src=\"/images/kafka/consumer_groups.png\"></p>\n<p>使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group 可同时消费这一消息。</p>\n<p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Comsumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不是需要多次发送消息到不同的Topic.</p>\n<h2 id=\"5-0-push-and-pull\"><a href=\"#5-0-push-and-pull\" class=\"headerlink\" title=\"5.0 push and pull\"></a>5.0 push and pull</h2><p>Kafka作为一个消息系统遵循了传统的方式，选择又Producer向broker push消息并由Consumer从broker pull消息。</p>\n<p>push模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成Consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据Consumer的消费能力以适当的速率消费消息。</p>\n<p>Kafka更适合pull模式，pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p>"},{"title":"Hello World","copyright":false,"image":"https://raw.githubusercontent.com/AshaoSunshine/ashaoimg/master/landscape/hello_world.webp","_content":"Hello World! 对于程序猿来说再熟悉不过了，我的博客也是从hello world 开始！\n<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;这是我第一次使用hexo写博客，之前写的是用python django网站搭建的。刚接触hexo,给我的感觉就是，真的太方便了。hexo编译，到github部署，不需要像之前自己买服务器，自己搭建了。目前，还在探索中。。。\n\n&nbsp;&nbsp;&nbsp;&nbsp;建立这个博客的初衷呢，就是想做个技术+生活的博客，虽然还在二流程序猿徘徊，但是也有一颗架构师的心，哈哈哈。\n\n![](https://raw.githubusercontent.com/AshaoSunshine/ashaoimg/master/landscape/pic_7.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;最后呢，还是那句话，“太阳尚远，但心有太阳！”\n\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: 日记\ncopyright: false\nimage: https://raw.githubusercontent.com/AshaoSunshine/ashaoimg/master/landscape/hello_world.webp\n---\nHello World! 对于程序猿来说再熟悉不过了，我的博客也是从hello world 开始！\n<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;这是我第一次使用hexo写博客，之前写的是用python django网站搭建的。刚接触hexo,给我的感觉就是，真的太方便了。hexo编译，到github部署，不需要像之前自己买服务器，自己搭建了。目前，还在探索中。。。\n\n&nbsp;&nbsp;&nbsp;&nbsp;建立这个博客的初衷呢，就是想做个技术+生活的博客，虽然还在二流程序猿徘徊，但是也有一颗架构师的心，哈哈哈。\n\n![](https://raw.githubusercontent.com/AshaoSunshine/ashaoimg/master/landscape/pic_7.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;最后呢，还是那句话，“太阳尚远，但心有太阳！”\n\n\n","slug":"hello-world","published":1,"date":"2021-07-19T02:25:25.963Z","updated":"2021-07-19T02:28:38.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra348wh0003zwva60lfc7bp","content":"<p>Hello World! 对于程序猿来说再熟悉不过了，我的博客也是从hello world 开始！</p>\n<span id=\"more\"></span>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;这是我第一次使用hexo写博客，之前写的是用python django网站搭建的。刚接触hexo,给我的感觉就是，真的太方便了。hexo编译，到github部署，不需要像之前自己买服务器，自己搭建了。目前，还在探索中。。。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;建立这个博客的初衷呢，就是想做个技术+生活的博客，虽然还在二流程序猿徘徊，但是也有一颗架构师的心，哈哈哈。</p>\n<p><img src=\"https://raw.githubusercontent.com/AshaoSunshine/ashaoimg/master/landscape/pic_7.jpg\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;最后呢，还是那句话，“太阳尚远，但心有太阳！”</p>\n","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"<p>Hello World! 对于程序猿来说再熟悉不过了，我的博客也是从hello world 开始！</p>","more":"<p>&nbsp;&nbsp;&nbsp;&nbsp;这是我第一次使用hexo写博客，之前写的是用python django网站搭建的。刚接触hexo,给我的感觉就是，真的太方便了。hexo编译，到github部署，不需要像之前自己买服务器，自己搭建了。目前，还在探索中。。。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;建立这个博客的初衷呢，就是想做个技术+生活的博客，虽然还在二流程序猿徘徊，但是也有一颗架构师的心，哈哈哈。</p>\n<p><img src=\"https://raw.githubusercontent.com/AshaoSunshine/ashaoimg/master/landscape/pic_7.jpg\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;最后呢，还是那句话，“太阳尚远，但心有太阳！”</p>"},{"title":"故宫，再看还是那么雄伟！","date":"2020-11-01T02:13:11.000Z","image":"/images/gugong/gugong_tag.jpg","copyright":false,"_content":"和之前不一样的，这次我们赶上了故宫的600岁。\n<!--more-->\n\ntest\ntest","source":"_posts/gugong_600years_diary.md","raw":"---\ntitle: 故宫，再看还是那么雄伟！\ndate: 2020-11-01 10:13:11\ntags:\ncategories: 日记\nimage: /images/gugong/gugong_tag.jpg\ncopyright: false\n---\n和之前不一样的，这次我们赶上了故宫的600岁。\n<!--more-->\n\ntest\ntest","slug":"gugong_600years_diary","published":1,"updated":"2021-07-19T02:28:40.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra348wl0007zwva1t1ca6ma","content":"<p>和之前不一样的，这次我们赶上了故宫的600岁。</p>\n<span id=\"more\"></span>\n\n<p>test<br>test</p>\n","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"<p>和之前不一样的，这次我们赶上了故宫的600岁。</p>","more":"<p>test<br>test</p>"},{"title":"kafka(三)","date":"2021-07-06T12:10:21.000Z","keywords":"Kafka,kafka","top":48,"image":"/images/kafka/kafka_tag_1.jpg","_content":"\nKafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。\n<!--more-->\n\n# **Apache Kafka 是一个分布式流处理平台。**\n\n## 1.0 Kafka HA 设计\n\n### 1.1 将Replica均匀分布到整个集群\n\nKafka尽力把所有的Partition均匀分配到集群上是为了负载均衡。 一个典型的部署方式是一个Topic的Partition数量大于broker的数量。同时为了提高Kafka的容错能力，也需要将同一个Partition的Replica尽量分散到不同的机器。如果所有的Replica都在同一个Broker上，那一旦该Broker宕机，该Partition的所有Replica都无法工作，也就达不到HA的效果。同时，如果某个Broker宕机了，需要保证它上面的负载可以被均匀的分配到其它幸存的所有Broker上。\n\n### 1.2 Data Replication(副本策略)\n\nKafka的高可靠性的保障来源于其健壮的副本（replication）策略。\n\n#### 1.2.1 消息传递同步策略\n\nproducer在发布消息到某个Partition时，先通过Zookeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将消息写入本地log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。\n\nKafka Replication的数据流如下图所示：\n\n![](/images/kafka/kafka_3_1.png)\n\n#### 1.2.2 选举Leader\n\n最简单最直观的方案是，所有Follower都在ZooKeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（ZooKeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。\n\n但是该方法会有3个问题：\n\n1.split-brain 这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致\n\n2.herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整\n\n3.ZooKeeper负载过重 每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。\n\nKafka 0.8.*的Leader Election方案解决了上述问题，它在所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比ZooKeeper Queue的方式更高效）通知需为为此作为响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。\n\n## 2.0 Kafka 高可用\n\n### 2.1 Replication\n\n在Kafka在0.8以前的版本中，是没有Replication的，一旦某一个Broker宕机，则其上所有的Partition数据都不可被消费，这与Kafka数据持久性及Delivery Guarantee的设计目标相悖。同时Producer都不能再将数据存于这些Partition中。\n\n如果Producer使用同步模式则Producer会在尝试重新发送message.send.max.retries（默认值为3）次后抛出Exception，用户可以选择停止发送后续数据也可选择继续选择发送。而前者会造成数据的阻塞，后者会造成本应发往该Broker的数据的丢失。\n\n如果Producer使用异步模式，则Producer会尝试重新发送message.send.max.retries（默认值为3）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题。同时，Kafka的Producer并未对异步模式提供callback接口。\n\n由此可见，在没有Replication的情况下，一旦某机器宕机或者某个Broker停止工作则会造成整个系统的可用性降低。随着集群规模的增加，整个集群中出现该类异常的几率大大增加，因此对于生产系统而言Replication机制的引入非常重要。\n\n### 2.1.2 Leader Election\n\n引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。\n\n因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一个宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（N×N条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的几率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。\n\n## 3.0 HA 相关ZooKeeper结构\n\n![](/images/kafka/kafka_3_2.png)\n\n### 3.1 admin\n\n该目录下znode只有在有相关操作时才会存在，操作结束时会将其删除\n\n/admin/reassign_partitions用于将一些Partition分配到不同的broker集合上。对于每个待重新分配的Partition，Kafka会在该znode上存储其所有的Replica和相应的Broker id。该znode由管理进程创建并且一旦重新分配成功它将会被自动移除。\n\n### 3.2 broker\n\n即/brokers/ids/[brokerId]）存储“活着”的broker信息。\n\ntopic注册信息（/brokers/topics/[topic]），存储该topic的所有partition的所有replica所在的broker id，第一个replica即为preferred replica，对一个给定的partition，它在同一个broker上最多只有一个replica,因此broker id可作为replica id。\n\n### 3.3 controller\n\n/controller -> int (broker id of the controller)存储当前controller的信息\n\n/controller_epoch -> int (epoch)直接以整数形式存储controller epoch，而非像其它znode一样以JSON字符串形式存储。\n\n","source":"_posts/kafka-3.md","raw":"---\ntitle: kafka(三)\ndate: 2021-07-06 20:10:21\ntags: Kafka\ncategories: 技术\nkeywords: Kafka,kafka\ntop: 48\nimage: /images/kafka/kafka_tag_1.jpg\n---\n\nKafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。\n<!--more-->\n\n# **Apache Kafka 是一个分布式流处理平台。**\n\n## 1.0 Kafka HA 设计\n\n### 1.1 将Replica均匀分布到整个集群\n\nKafka尽力把所有的Partition均匀分配到集群上是为了负载均衡。 一个典型的部署方式是一个Topic的Partition数量大于broker的数量。同时为了提高Kafka的容错能力，也需要将同一个Partition的Replica尽量分散到不同的机器。如果所有的Replica都在同一个Broker上，那一旦该Broker宕机，该Partition的所有Replica都无法工作，也就达不到HA的效果。同时，如果某个Broker宕机了，需要保证它上面的负载可以被均匀的分配到其它幸存的所有Broker上。\n\n### 1.2 Data Replication(副本策略)\n\nKafka的高可靠性的保障来源于其健壮的副本（replication）策略。\n\n#### 1.2.1 消息传递同步策略\n\nproducer在发布消息到某个Partition时，先通过Zookeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将消息写入本地log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。\n\nKafka Replication的数据流如下图所示：\n\n![](/images/kafka/kafka_3_1.png)\n\n#### 1.2.2 选举Leader\n\n最简单最直观的方案是，所有Follower都在ZooKeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（ZooKeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。\n\n但是该方法会有3个问题：\n\n1.split-brain 这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致\n\n2.herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整\n\n3.ZooKeeper负载过重 每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。\n\nKafka 0.8.*的Leader Election方案解决了上述问题，它在所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比ZooKeeper Queue的方式更高效）通知需为为此作为响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。\n\n## 2.0 Kafka 高可用\n\n### 2.1 Replication\n\n在Kafka在0.8以前的版本中，是没有Replication的，一旦某一个Broker宕机，则其上所有的Partition数据都不可被消费，这与Kafka数据持久性及Delivery Guarantee的设计目标相悖。同时Producer都不能再将数据存于这些Partition中。\n\n如果Producer使用同步模式则Producer会在尝试重新发送message.send.max.retries（默认值为3）次后抛出Exception，用户可以选择停止发送后续数据也可选择继续选择发送。而前者会造成数据的阻塞，后者会造成本应发往该Broker的数据的丢失。\n\n如果Producer使用异步模式，则Producer会尝试重新发送message.send.max.retries（默认值为3）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题。同时，Kafka的Producer并未对异步模式提供callback接口。\n\n由此可见，在没有Replication的情况下，一旦某机器宕机或者某个Broker停止工作则会造成整个系统的可用性降低。随着集群规模的增加，整个集群中出现该类异常的几率大大增加，因此对于生产系统而言Replication机制的引入非常重要。\n\n### 2.1.2 Leader Election\n\n引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。\n\n因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一个宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（N×N条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的几率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。\n\n## 3.0 HA 相关ZooKeeper结构\n\n![](/images/kafka/kafka_3_2.png)\n\n### 3.1 admin\n\n该目录下znode只有在有相关操作时才会存在，操作结束时会将其删除\n\n/admin/reassign_partitions用于将一些Partition分配到不同的broker集合上。对于每个待重新分配的Partition，Kafka会在该znode上存储其所有的Replica和相应的Broker id。该znode由管理进程创建并且一旦重新分配成功它将会被自动移除。\n\n### 3.2 broker\n\n即/brokers/ids/[brokerId]）存储“活着”的broker信息。\n\ntopic注册信息（/brokers/topics/[topic]），存储该topic的所有partition的所有replica所在的broker id，第一个replica即为preferred replica，对一个给定的partition，它在同一个broker上最多只有一个replica,因此broker id可作为replica id。\n\n### 3.3 controller\n\n/controller -> int (broker id of the controller)存储当前controller的信息\n\n/controller_epoch -> int (epoch)直接以整数形式存储controller epoch，而非像其它znode一样以JSON字符串形式存储。\n\n","slug":"kafka-3","published":1,"updated":"2021-07-19T02:25:25.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra348wm0009zwvadyvh9mwf","content":"<p>Kafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Apache-Kafka-是一个分布式流处理平台。\"><a href=\"#Apache-Kafka-是一个分布式流处理平台。\" class=\"headerlink\" title=\"Apache Kafka 是一个分布式流处理平台。\"></a><strong>Apache Kafka 是一个分布式流处理平台。</strong></h1><h2 id=\"1-0-Kafka-HA-设计\"><a href=\"#1-0-Kafka-HA-设计\" class=\"headerlink\" title=\"1.0 Kafka HA 设计\"></a>1.0 Kafka HA 设计</h2><h3 id=\"1-1-将Replica均匀分布到整个集群\"><a href=\"#1-1-将Replica均匀分布到整个集群\" class=\"headerlink\" title=\"1.1 将Replica均匀分布到整个集群\"></a>1.1 将Replica均匀分布到整个集群</h3><p>Kafka尽力把所有的Partition均匀分配到集群上是为了负载均衡。 一个典型的部署方式是一个Topic的Partition数量大于broker的数量。同时为了提高Kafka的容错能力，也需要将同一个Partition的Replica尽量分散到不同的机器。如果所有的Replica都在同一个Broker上，那一旦该Broker宕机，该Partition的所有Replica都无法工作，也就达不到HA的效果。同时，如果某个Broker宕机了，需要保证它上面的负载可以被均匀的分配到其它幸存的所有Broker上。</p>\n<h3 id=\"1-2-Data-Replication-副本策略\"><a href=\"#1-2-Data-Replication-副本策略\" class=\"headerlink\" title=\"1.2 Data Replication(副本策略)\"></a>1.2 Data Replication(副本策略)</h3><p>Kafka的高可靠性的保障来源于其健壮的副本（replication）策略。</p>\n<h4 id=\"1-2-1-消息传递同步策略\"><a href=\"#1-2-1-消息传递同步策略\" class=\"headerlink\" title=\"1.2.1 消息传递同步策略\"></a>1.2.1 消息传递同步策略</h4><p>producer在发布消息到某个Partition时，先通过Zookeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将消息写入本地log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。</p>\n<p>Kafka Replication的数据流如下图所示：</p>\n<p><img src=\"/images/kafka/kafka_3_1.png\"></p>\n<h4 id=\"1-2-2-选举Leader\"><a href=\"#1-2-2-选举Leader\" class=\"headerlink\" title=\"1.2.2 选举Leader\"></a>1.2.2 选举Leader</h4><p>最简单最直观的方案是，所有Follower都在ZooKeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（ZooKeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。</p>\n<p>但是该方法会有3个问题：</p>\n<p>1.split-brain 这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致</p>\n<p>2.herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整</p>\n<p>3.ZooKeeper负载过重 每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。</p>\n<p>Kafka 0.8.*的Leader Election方案解决了上述问题，它在所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比ZooKeeper Queue的方式更高效）通知需为为此作为响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。</p>\n<h2 id=\"2-0-Kafka-高可用\"><a href=\"#2-0-Kafka-高可用\" class=\"headerlink\" title=\"2.0 Kafka 高可用\"></a>2.0 Kafka 高可用</h2><h3 id=\"2-1-Replication\"><a href=\"#2-1-Replication\" class=\"headerlink\" title=\"2.1 Replication\"></a>2.1 Replication</h3><p>在Kafka在0.8以前的版本中，是没有Replication的，一旦某一个Broker宕机，则其上所有的Partition数据都不可被消费，这与Kafka数据持久性及Delivery Guarantee的设计目标相悖。同时Producer都不能再将数据存于这些Partition中。</p>\n<p>如果Producer使用同步模式则Producer会在尝试重新发送message.send.max.retries（默认值为3）次后抛出Exception，用户可以选择停止发送后续数据也可选择继续选择发送。而前者会造成数据的阻塞，后者会造成本应发往该Broker的数据的丢失。</p>\n<p>如果Producer使用异步模式，则Producer会尝试重新发送message.send.max.retries（默认值为3）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题。同时，Kafka的Producer并未对异步模式提供callback接口。</p>\n<p>由此可见，在没有Replication的情况下，一旦某机器宕机或者某个Broker停止工作则会造成整个系统的可用性降低。随着集群规模的增加，整个集群中出现该类异常的几率大大增加，因此对于生产系统而言Replication机制的引入非常重要。</p>\n<h3 id=\"2-1-2-Leader-Election\"><a href=\"#2-1-2-Leader-Election\" class=\"headerlink\" title=\"2.1.2 Leader Election\"></a>2.1.2 Leader Election</h3><p>引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。</p>\n<p>因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一个宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（N×N条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的几率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。</p>\n<h2 id=\"3-0-HA-相关ZooKeeper结构\"><a href=\"#3-0-HA-相关ZooKeeper结构\" class=\"headerlink\" title=\"3.0 HA 相关ZooKeeper结构\"></a>3.0 HA 相关ZooKeeper结构</h2><p><img src=\"/images/kafka/kafka_3_2.png\"></p>\n<h3 id=\"3-1-admin\"><a href=\"#3-1-admin\" class=\"headerlink\" title=\"3.1 admin\"></a>3.1 admin</h3><p>该目录下znode只有在有相关操作时才会存在，操作结束时会将其删除</p>\n<p>/admin/reassign_partitions用于将一些Partition分配到不同的broker集合上。对于每个待重新分配的Partition，Kafka会在该znode上存储其所有的Replica和相应的Broker id。该znode由管理进程创建并且一旦重新分配成功它将会被自动移除。</p>\n<h3 id=\"3-2-broker\"><a href=\"#3-2-broker\" class=\"headerlink\" title=\"3.2 broker\"></a>3.2 broker</h3><p>即/brokers/ids/[brokerId]）存储“活着”的broker信息。</p>\n<p>topic注册信息（/brokers/topics/[topic]），存储该topic的所有partition的所有replica所在的broker id，第一个replica即为preferred replica，对一个给定的partition，它在同一个broker上最多只有一个replica,因此broker id可作为replica id。</p>\n<h3 id=\"3-3-controller\"><a href=\"#3-3-controller\" class=\"headerlink\" title=\"3.3 controller\"></a>3.3 controller</h3><p>/controller -&gt; int (broker id of the controller)存储当前controller的信息</p>\n<p>/controller_epoch -&gt; int (epoch)直接以整数形式存储controller epoch，而非像其它znode一样以JSON字符串形式存储。</p>\n","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"<p>Kafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。</p>","more":"<h1 id=\"Apache-Kafka-是一个分布式流处理平台。\"><a href=\"#Apache-Kafka-是一个分布式流处理平台。\" class=\"headerlink\" title=\"Apache Kafka 是一个分布式流处理平台。\"></a><strong>Apache Kafka 是一个分布式流处理平台。</strong></h1><h2 id=\"1-0-Kafka-HA-设计\"><a href=\"#1-0-Kafka-HA-设计\" class=\"headerlink\" title=\"1.0 Kafka HA 设计\"></a>1.0 Kafka HA 设计</h2><h3 id=\"1-1-将Replica均匀分布到整个集群\"><a href=\"#1-1-将Replica均匀分布到整个集群\" class=\"headerlink\" title=\"1.1 将Replica均匀分布到整个集群\"></a>1.1 将Replica均匀分布到整个集群</h3><p>Kafka尽力把所有的Partition均匀分配到集群上是为了负载均衡。 一个典型的部署方式是一个Topic的Partition数量大于broker的数量。同时为了提高Kafka的容错能力，也需要将同一个Partition的Replica尽量分散到不同的机器。如果所有的Replica都在同一个Broker上，那一旦该Broker宕机，该Partition的所有Replica都无法工作，也就达不到HA的效果。同时，如果某个Broker宕机了，需要保证它上面的负载可以被均匀的分配到其它幸存的所有Broker上。</p>\n<h3 id=\"1-2-Data-Replication-副本策略\"><a href=\"#1-2-Data-Replication-副本策略\" class=\"headerlink\" title=\"1.2 Data Replication(副本策略)\"></a>1.2 Data Replication(副本策略)</h3><p>Kafka的高可靠性的保障来源于其健壮的副本（replication）策略。</p>\n<h4 id=\"1-2-1-消息传递同步策略\"><a href=\"#1-2-1-消息传递同步策略\" class=\"headerlink\" title=\"1.2.1 消息传递同步策略\"></a>1.2.1 消息传递同步策略</h4><p>producer在发布消息到某个Partition时，先通过Zookeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将消息写入本地log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。</p>\n<p>Kafka Replication的数据流如下图所示：</p>\n<p><img src=\"/images/kafka/kafka_3_1.png\"></p>\n<h4 id=\"1-2-2-选举Leader\"><a href=\"#1-2-2-选举Leader\" class=\"headerlink\" title=\"1.2.2 选举Leader\"></a>1.2.2 选举Leader</h4><p>最简单最直观的方案是，所有Follower都在ZooKeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（ZooKeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。</p>\n<p>但是该方法会有3个问题：</p>\n<p>1.split-brain 这是由ZooKeeper的特性引起的，虽然ZooKeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致</p>\n<p>2.herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整</p>\n<p>3.ZooKeeper负载过重 每个Replica都要为此在ZooKeeper上注册一个Watch，当集群规模增加到几千个Partition时ZooKeeper负载会过重。</p>\n<p>Kafka 0.8.*的Leader Election方案解决了上述问题，它在所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比ZooKeeper Queue的方式更高效）通知需为为此作为响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。</p>\n<h2 id=\"2-0-Kafka-高可用\"><a href=\"#2-0-Kafka-高可用\" class=\"headerlink\" title=\"2.0 Kafka 高可用\"></a>2.0 Kafka 高可用</h2><h3 id=\"2-1-Replication\"><a href=\"#2-1-Replication\" class=\"headerlink\" title=\"2.1 Replication\"></a>2.1 Replication</h3><p>在Kafka在0.8以前的版本中，是没有Replication的，一旦某一个Broker宕机，则其上所有的Partition数据都不可被消费，这与Kafka数据持久性及Delivery Guarantee的设计目标相悖。同时Producer都不能再将数据存于这些Partition中。</p>\n<p>如果Producer使用同步模式则Producer会在尝试重新发送message.send.max.retries（默认值为3）次后抛出Exception，用户可以选择停止发送后续数据也可选择继续选择发送。而前者会造成数据的阻塞，后者会造成本应发往该Broker的数据的丢失。</p>\n<p>如果Producer使用异步模式，则Producer会尝试重新发送message.send.max.retries（默认值为3）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题。同时，Kafka的Producer并未对异步模式提供callback接口。</p>\n<p>由此可见，在没有Replication的情况下，一旦某机器宕机或者某个Broker停止工作则会造成整个系统的可用性降低。随着集群规模的增加，整个集群中出现该类异常的几率大大增加，因此对于生产系统而言Replication机制的引入非常重要。</p>\n<h3 id=\"2-1-2-Leader-Election\"><a href=\"#2-1-2-Leader-Election\" class=\"headerlink\" title=\"2.1.2 Leader Election\"></a>2.1.2 Leader Election</h3><p>引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。</p>\n<p>因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一个宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（N×N条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的几率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。</p>\n<h2 id=\"3-0-HA-相关ZooKeeper结构\"><a href=\"#3-0-HA-相关ZooKeeper结构\" class=\"headerlink\" title=\"3.0 HA 相关ZooKeeper结构\"></a>3.0 HA 相关ZooKeeper结构</h2><p><img src=\"/images/kafka/kafka_3_2.png\"></p>\n<h3 id=\"3-1-admin\"><a href=\"#3-1-admin\" class=\"headerlink\" title=\"3.1 admin\"></a>3.1 admin</h3><p>该目录下znode只有在有相关操作时才会存在，操作结束时会将其删除</p>\n<p>/admin/reassign_partitions用于将一些Partition分配到不同的broker集合上。对于每个待重新分配的Partition，Kafka会在该znode上存储其所有的Replica和相应的Broker id。该znode由管理进程创建并且一旦重新分配成功它将会被自动移除。</p>\n<h3 id=\"3-2-broker\"><a href=\"#3-2-broker\" class=\"headerlink\" title=\"3.2 broker\"></a>3.2 broker</h3><p>即/brokers/ids/[brokerId]）存储“活着”的broker信息。</p>\n<p>topic注册信息（/brokers/topics/[topic]），存储该topic的所有partition的所有replica所在的broker id，第一个replica即为preferred replica，对一个给定的partition，它在同一个broker上最多只有一个replica,因此broker id可作为replica id。</p>\n<h3 id=\"3-3-controller\"><a href=\"#3-3-controller\" class=\"headerlink\" title=\"3.3 controller\"></a>3.3 controller</h3><p>/controller -&gt; int (broker id of the controller)存储当前controller的信息</p>\n<p>/controller_epoch -&gt; int (epoch)直接以整数形式存储controller epoch，而非像其它znode一样以JSON字符串形式存储。</p>"},{"title":"sqlalchemy","date":"2021-07-09T07:56:58.000Z","keywords":"sqlalchemy","top":null,"image":"images/sql/sql_1.webp","_content":"SQLAlchemy 是一个功能强大的python ORM工具包。\n<!--more-->\n\n## 1.0 模型定义\n\nmodel等同于数据库中的表。  \n```python   \nfrom __future__ import unicode_literals, absolute_import\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column, Integer, String, DateTime\nModelBase = declarative_base()\nclass User(ModelBase):\n    __tablename__ = \"auth_info\"\n\n    id = Column(Integer, primary_key=True)\n    date_joined = Column(DateTime)\n    username = Column(String(length=30))\n    password = Column(String(length=128))\n```\n\n## 2.0 增删改查  \n\n### 在用sqlalchemy时，通常先定义个类，方便之后调用。\n```python\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import create_engine\n\n\nclass SqlalchemyTool(object):\n    def __init__(self,db):\n        self.db = db\n        self.uri = \"mysql+pymysql://{user}:{pwd}@{host}:{port}/{db}?charset=utf8\".format(user=config.Mysql.user,host=config.Mysql.server,port=config.Mysql.port,db=self.db,pwd=config.Mysql.pwd)\n        __engine = create_engine(self.uri, encoding='utf-8', echo=False)\n        Session_class = sessionmaker(bind=__engine)\n        self.session = Session_class()\n\n\n    def __enter__(self):\n        return self.session\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.session:\n            self.session.close()\n```\n\n### 增（add）   \n```python\nwith SqlalchemyTool(这里写数据库) as session:\n    sql = UserTable(username='username', password='password')\n    session.add(sql)\n    session.commit()\n```\n**session**可以看成一个管理数据库持久连接的对象。  \nsession.add函数会把model加入当前的持久空间，直到session.commit提交。  \n\n### 删（delete）\n```python\nwith SqlalchemyTool(这里写数据库) as session:\n    record = session.query(User).filter(User.username == 'username')\n    session.delete(record)\n    session.commit()\n    # 或者 session.query(User).filter_by(username='username').delete()\n```\n**filter**相当于where,过滤条件。\n\n### 改（update）\n```python\nwith SqlalchemyTool(这里写数据库) as session:\n    session.query(User).filter(User.username == 'username').update(\n        {\"password\": 'password1'}\n    )\n    session.commit()\n```\n**update** 进行修改相关数据库内容，在对model的属性进行修改时，session会得到修改对应的内容，下次commit即会提交sql。\n\n### 查（query）\n```python\nwith SqlalchemyTool(这里写数据库) as session:\n    session.query(User).filter((User.username == 'username')\n    # 和 select * from User  等同\n    # session.query(User.username).filter((User.username == 'username')\n```\n\n[详情查看官方文档。](https://docs.sqlalchemy.org/en/14/)","source":"_posts/sqlalchemy.md","raw":"---\ntitle: sqlalchemy\ndate: 2021-07-09 15:56:58\ntags: sql\ncategories: 技术\nkeywords: sqlalchemy\ntop: \nimage: images/sql/sql_1.webp\n---\nSQLAlchemy 是一个功能强大的python ORM工具包。\n<!--more-->\n\n## 1.0 模型定义\n\nmodel等同于数据库中的表。  \n```python   \nfrom __future__ import unicode_literals, absolute_import\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column, Integer, String, DateTime\nModelBase = declarative_base()\nclass User(ModelBase):\n    __tablename__ = \"auth_info\"\n\n    id = Column(Integer, primary_key=True)\n    date_joined = Column(DateTime)\n    username = Column(String(length=30))\n    password = Column(String(length=128))\n```\n\n## 2.0 增删改查  \n\n### 在用sqlalchemy时，通常先定义个类，方便之后调用。\n```python\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import create_engine\n\n\nclass SqlalchemyTool(object):\n    def __init__(self,db):\n        self.db = db\n        self.uri = \"mysql+pymysql://{user}:{pwd}@{host}:{port}/{db}?charset=utf8\".format(user=config.Mysql.user,host=config.Mysql.server,port=config.Mysql.port,db=self.db,pwd=config.Mysql.pwd)\n        __engine = create_engine(self.uri, encoding='utf-8', echo=False)\n        Session_class = sessionmaker(bind=__engine)\n        self.session = Session_class()\n\n\n    def __enter__(self):\n        return self.session\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.session:\n            self.session.close()\n```\n\n### 增（add）   \n```python\nwith SqlalchemyTool(这里写数据库) as session:\n    sql = UserTable(username='username', password='password')\n    session.add(sql)\n    session.commit()\n```\n**session**可以看成一个管理数据库持久连接的对象。  \nsession.add函数会把model加入当前的持久空间，直到session.commit提交。  \n\n### 删（delete）\n```python\nwith SqlalchemyTool(这里写数据库) as session:\n    record = session.query(User).filter(User.username == 'username')\n    session.delete(record)\n    session.commit()\n    # 或者 session.query(User).filter_by(username='username').delete()\n```\n**filter**相当于where,过滤条件。\n\n### 改（update）\n```python\nwith SqlalchemyTool(这里写数据库) as session:\n    session.query(User).filter(User.username == 'username').update(\n        {\"password\": 'password1'}\n    )\n    session.commit()\n```\n**update** 进行修改相关数据库内容，在对model的属性进行修改时，session会得到修改对应的内容，下次commit即会提交sql。\n\n### 查（query）\n```python\nwith SqlalchemyTool(这里写数据库) as session:\n    session.query(User).filter((User.username == 'username')\n    # 和 select * from User  等同\n    # session.query(User.username).filter((User.username == 'username')\n```\n\n[详情查看官方文档。](https://docs.sqlalchemy.org/en/14/)","slug":"sqlalchemy","published":1,"updated":"2021-07-19T03:32:10.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra348wo000bzwvahvpq0aug","content":"<p>SQLAlchemy 是一个功能强大的python ORM工具包。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1-0-模型定义\"><a href=\"#1-0-模型定义\" class=\"headerlink\" title=\"1.0 模型定义\"></a>1.0 模型定义</h2><p>model等同于数据库中的表。  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> unicode_literals, absolute_import</span><br><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy.ext.declarative <span class=\"keyword\">import</span> declarative_base</span><br><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy <span class=\"keyword\">import</span> Column, Integer, String, DateTime</span><br><span class=\"line\">ModelBase = declarative_base()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">ModelBase</span>):</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">&quot;auth_info&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">id</span> = Column(Integer, primary_key=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    date_joined = Column(DateTime)</span><br><span class=\"line\">    username = Column(String(length=<span class=\"number\">30</span>))</span><br><span class=\"line\">    password = Column(String(length=<span class=\"number\">128</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-0-增删改查\"><a href=\"#2-0-增删改查\" class=\"headerlink\" title=\"2.0 增删改查\"></a>2.0 增删改查</h2><h3 id=\"在用sqlalchemy时，通常先定义个类，方便之后调用。\"><a href=\"#在用sqlalchemy时，通常先定义个类，方便之后调用。\" class=\"headerlink\" title=\"在用sqlalchemy时，通常先定义个类，方便之后调用。\"></a>在用sqlalchemy时，通常先定义个类，方便之后调用。</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy.orm <span class=\"keyword\">import</span> sessionmaker</span><br><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy <span class=\"keyword\">import</span> create_engine</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SqlalchemyTool</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,db</span>):</span></span><br><span class=\"line\">        self.db = db</span><br><span class=\"line\">        self.uri = <span class=\"string\">&quot;mysql+pymysql://&#123;user&#125;:&#123;pwd&#125;@&#123;host&#125;:&#123;port&#125;/&#123;db&#125;?charset=utf8&quot;</span>.<span class=\"built_in\">format</span>(user=config.Mysql.user,host=config.Mysql.server,port=config.Mysql.port,db=self.db,pwd=config.Mysql.pwd)</span><br><span class=\"line\">        __engine = create_engine(self.uri, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>, echo=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        Session_class = sessionmaker(bind=__engine)</span><br><span class=\"line\">        self.session = Session_class()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__enter__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.session</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__exit__</span>(<span class=\"params\">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.session:</span><br><span class=\"line\">            self.session.close()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增（add）\"><a href=\"#增（add）\" class=\"headerlink\" title=\"增（add）\"></a>增（add）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> SqlalchemyTool(这里写数据库) <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    sql = UserTable(username=<span class=\"string\">&#x27;username&#x27;</span>, password=<span class=\"string\">&#x27;password&#x27;</span>)</span><br><span class=\"line\">    session.add(sql)</span><br><span class=\"line\">    session.commit()</span><br></pre></td></tr></table></figure>\n<p><strong>session</strong>可以看成一个管理数据库持久连接的对象。<br>session.add函数会把model加入当前的持久空间，直到session.commit提交。  </p>\n<h3 id=\"删（delete）\"><a href=\"#删（delete）\" class=\"headerlink\" title=\"删（delete）\"></a>删（delete）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> SqlalchemyTool(这里写数据库) <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    record = session.query(User).<span class=\"built_in\">filter</span>(User.username == <span class=\"string\">&#x27;username&#x27;</span>)</span><br><span class=\"line\">    session.delete(record)</span><br><span class=\"line\">    session.commit()</span><br><span class=\"line\">    <span class=\"comment\"># 或者 session.query(User).filter_by(username=&#x27;username&#x27;).delete()</span></span><br></pre></td></tr></table></figure>\n<p><strong>filter</strong>相当于where,过滤条件。</p>\n<h3 id=\"改（update）\"><a href=\"#改（update）\" class=\"headerlink\" title=\"改（update）\"></a>改（update）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> SqlalchemyTool(这里写数据库) <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    session.query(User).<span class=\"built_in\">filter</span>(User.username == <span class=\"string\">&#x27;username&#x27;</span>).update(</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;password&quot;</span>: <span class=\"string\">&#x27;password1&#x27;</span>&#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    session.commit()</span><br></pre></td></tr></table></figure>\n<p><strong>update</strong> 进行修改相关数据库内容，在对model的属性进行修改时，session会得到修改对应的内容，下次commit即会提交sql。</p>\n<h3 id=\"查（query）\"><a href=\"#查（query）\" class=\"headerlink\" title=\"查（query）\"></a>查（query）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> SqlalchemyTool(这里写数据库) <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    session.query(User).<span class=\"built_in\">filter</span>((User.username == <span class=\"string\">&#x27;username&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 和 select * from User  等同</span></span><br><span class=\"line\">    <span class=\"comment\"># session.query(User.username).filter((User.username == &#x27;username&#x27;)</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://docs.sqlalchemy.org/en/14/\">详情查看官方文档。</a></p>\n","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"<p>SQLAlchemy 是一个功能强大的python ORM工具包。</p>","more":"<h2 id=\"1-0-模型定义\"><a href=\"#1-0-模型定义\" class=\"headerlink\" title=\"1.0 模型定义\"></a>1.0 模型定义</h2><p>model等同于数据库中的表。  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> unicode_literals, absolute_import</span><br><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy.ext.declarative <span class=\"keyword\">import</span> declarative_base</span><br><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy <span class=\"keyword\">import</span> Column, Integer, String, DateTime</span><br><span class=\"line\">ModelBase = declarative_base()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">ModelBase</span>):</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">&quot;auth_info&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">id</span> = Column(Integer, primary_key=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    date_joined = Column(DateTime)</span><br><span class=\"line\">    username = Column(String(length=<span class=\"number\">30</span>))</span><br><span class=\"line\">    password = Column(String(length=<span class=\"number\">128</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-0-增删改查\"><a href=\"#2-0-增删改查\" class=\"headerlink\" title=\"2.0 增删改查\"></a>2.0 增删改查</h2><h3 id=\"在用sqlalchemy时，通常先定义个类，方便之后调用。\"><a href=\"#在用sqlalchemy时，通常先定义个类，方便之后调用。\" class=\"headerlink\" title=\"在用sqlalchemy时，通常先定义个类，方便之后调用。\"></a>在用sqlalchemy时，通常先定义个类，方便之后调用。</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy.orm <span class=\"keyword\">import</span> sessionmaker</span><br><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy <span class=\"keyword\">import</span> create_engine</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SqlalchemyTool</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,db</span>):</span></span><br><span class=\"line\">        self.db = db</span><br><span class=\"line\">        self.uri = <span class=\"string\">&quot;mysql+pymysql://&#123;user&#125;:&#123;pwd&#125;@&#123;host&#125;:&#123;port&#125;/&#123;db&#125;?charset=utf8&quot;</span>.<span class=\"built_in\">format</span>(user=config.Mysql.user,host=config.Mysql.server,port=config.Mysql.port,db=self.db,pwd=config.Mysql.pwd)</span><br><span class=\"line\">        __engine = create_engine(self.uri, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>, echo=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        Session_class = sessionmaker(bind=__engine)</span><br><span class=\"line\">        self.session = Session_class()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__enter__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.session</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__exit__</span>(<span class=\"params\">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.session:</span><br><span class=\"line\">            self.session.close()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增（add）\"><a href=\"#增（add）\" class=\"headerlink\" title=\"增（add）\"></a>增（add）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> SqlalchemyTool(这里写数据库) <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    sql = UserTable(username=<span class=\"string\">&#x27;username&#x27;</span>, password=<span class=\"string\">&#x27;password&#x27;</span>)</span><br><span class=\"line\">    session.add(sql)</span><br><span class=\"line\">    session.commit()</span><br></pre></td></tr></table></figure>\n<p><strong>session</strong>可以看成一个管理数据库持久连接的对象。<br>session.add函数会把model加入当前的持久空间，直到session.commit提交。  </p>\n<h3 id=\"删（delete）\"><a href=\"#删（delete）\" class=\"headerlink\" title=\"删（delete）\"></a>删（delete）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> SqlalchemyTool(这里写数据库) <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    record = session.query(User).<span class=\"built_in\">filter</span>(User.username == <span class=\"string\">&#x27;username&#x27;</span>)</span><br><span class=\"line\">    session.delete(record)</span><br><span class=\"line\">    session.commit()</span><br><span class=\"line\">    <span class=\"comment\"># 或者 session.query(User).filter_by(username=&#x27;username&#x27;).delete()</span></span><br></pre></td></tr></table></figure>\n<p><strong>filter</strong>相当于where,过滤条件。</p>\n<h3 id=\"改（update）\"><a href=\"#改（update）\" class=\"headerlink\" title=\"改（update）\"></a>改（update）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> SqlalchemyTool(这里写数据库) <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    session.query(User).<span class=\"built_in\">filter</span>(User.username == <span class=\"string\">&#x27;username&#x27;</span>).update(</span><br><span class=\"line\">        &#123;<span class=\"string\">&quot;password&quot;</span>: <span class=\"string\">&#x27;password1&#x27;</span>&#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    session.commit()</span><br></pre></td></tr></table></figure>\n<p><strong>update</strong> 进行修改相关数据库内容，在对model的属性进行修改时，session会得到修改对应的内容，下次commit即会提交sql。</p>\n<h3 id=\"查（query）\"><a href=\"#查（query）\" class=\"headerlink\" title=\"查（query）\"></a>查（query）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> SqlalchemyTool(这里写数据库) <span class=\"keyword\">as</span> session:</span><br><span class=\"line\">    session.query(User).<span class=\"built_in\">filter</span>((User.username == <span class=\"string\">&#x27;username&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 和 select * from User  等同</span></span><br><span class=\"line\">    <span class=\"comment\"># session.query(User.username).filter((User.username == &#x27;username&#x27;)</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://docs.sqlalchemy.org/en/14/\">详情查看官方文档。</a></p>"},{"title":"nacos","date":"2021-07-09T07:56:58.000Z","keywords":"Nacos,nacos","top":null,"image":"https://raw.githubusercontent.com/AshaoSunshine/ashaoimg/master/landscape/landscape_2.jpg","_content":"","source":"_posts/nacos-1.md","raw":"---\ntitle: nacos\ndate: 2021-07-09 15:56:58\ntags: nacos\ncategories: 技术\nkeywords: Nacos,nacos\ntop: \nimage: https://raw.githubusercontent.com/AshaoSunshine/ashaoimg/master/landscape/landscape_2.jpg\n---\n","slug":"nacos-1","published":1,"updated":"2021-07-19T02:25:25.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra348wp000fzwva76v1f3ko","content":"","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"","more":""},{"title":"两只老虎","date":"2021-07-09T07:56:58.000Z","image":"/images/tiger/two_tigers.jpg","_content":"","source":"_posts/two_tigers.md","raw":"---\ntitle: 两只老虎\ndate: 2021-07-09 15:56:58\nimage: /images/tiger/two_tigers.jpg\n---\n","slug":"two_tigers","published":1,"updated":"2021-07-19T02:25:25.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra348ws000izwvahexbgxgi","content":"","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"","more":""},{"title":"夏天的风，你我漫步在沙滩~","date":"2021-06-19T07:51:20.000Z","copyright":false,"image":"/images/xiamen/xiamen_tag.jpg","_content":"对，没错，我们一起吹着晚风，在沙滩漫步，就像电影里那样！\n<!--more-->\n&nbsp;&nbsp;&nbsp;&nbsp;这是我们一直想要去的厦门。\n\n&nbsp;&nbsp;&nbsp;&nbsp;是啊，我们的厦门！\n\n&nbsp;&nbsp;&nbsp;&nbsp;去厦门之前，我们一直在想，厦门是什么样的，鼓浪屿，真的娜么浪漫吗？\n\n&nbsp;&nbsp;&nbsp;&nbsp;娜宝一直反复的修改攻略，而我呢就负责路上的票，给她打下手。\n\n&nbsp;&nbsp;&nbsp;&nbsp;就这样，我们出发了~\n\n&nbsp;&nbsp;&nbsp;&nbsp;好运呢，也是一直眷恋着我们，一切都是那么刚刚好，\n\n&nbsp;&nbsp;&nbsp;&nbsp;刚好的托运，\n\n&nbsp;&nbsp;&nbsp;&nbsp;刚好的检票，（应为快登机了，走的快速通道。哈哈哈！）\n\n&nbsp;&nbsp;&nbsp;&nbsp;接着我们又一路冲刺快速的找到我们的航班检票口，真的差点检票口就关闭了，又是刚刚好~\n\n&nbsp;&nbsp;&nbsp;&nbsp;出口刚好的一趟摆渡车，\n\n&nbsp;&nbsp;&nbsp;&nbsp;终于坐上了去往厦门的飞机。\n\n\n\n","source":"_posts/xiamen_diary.md","raw":"---\ntitle: 夏天的风，你我漫步在沙滩~  \ndate: 2021-06-19 15:51:20\ntags:\ncategories: 日记\ncopyright: false\nimage: /images/xiamen/xiamen_tag.jpg\n---\n对，没错，我们一起吹着晚风，在沙滩漫步，就像电影里那样！\n<!--more-->\n&nbsp;&nbsp;&nbsp;&nbsp;这是我们一直想要去的厦门。\n\n&nbsp;&nbsp;&nbsp;&nbsp;是啊，我们的厦门！\n\n&nbsp;&nbsp;&nbsp;&nbsp;去厦门之前，我们一直在想，厦门是什么样的，鼓浪屿，真的娜么浪漫吗？\n\n&nbsp;&nbsp;&nbsp;&nbsp;娜宝一直反复的修改攻略，而我呢就负责路上的票，给她打下手。\n\n&nbsp;&nbsp;&nbsp;&nbsp;就这样，我们出发了~\n\n&nbsp;&nbsp;&nbsp;&nbsp;好运呢，也是一直眷恋着我们，一切都是那么刚刚好，\n\n&nbsp;&nbsp;&nbsp;&nbsp;刚好的托运，\n\n&nbsp;&nbsp;&nbsp;&nbsp;刚好的检票，（应为快登机了，走的快速通道。哈哈哈！）\n\n&nbsp;&nbsp;&nbsp;&nbsp;接着我们又一路冲刺快速的找到我们的航班检票口，真的差点检票口就关闭了，又是刚刚好~\n\n&nbsp;&nbsp;&nbsp;&nbsp;出口刚好的一趟摆渡车，\n\n&nbsp;&nbsp;&nbsp;&nbsp;终于坐上了去往厦门的飞机。\n\n\n\n","slug":"xiamen_diary","published":1,"updated":"2021-07-19T02:25:25.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra348wv000lzwva25hue54a","content":"<p>对，没错，我们一起吹着晚风，在沙滩漫步，就像电影里那样！</p>\n<span id=\"more\"></span>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;这是我们一直想要去的厦门。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;是啊，我们的厦门！</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;去厦门之前，我们一直在想，厦门是什么样的，鼓浪屿，真的娜么浪漫吗？</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;娜宝一直反复的修改攻略，而我呢就负责路上的票，给她打下手。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;就这样，我们出发了~</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;好运呢，也是一直眷恋着我们，一切都是那么刚刚好，</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;刚好的托运，</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;刚好的检票，（应为快登机了，走的快速通道。哈哈哈！）</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;接着我们又一路冲刺快速的找到我们的航班检票口，真的差点检票口就关闭了，又是刚刚好~</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;出口刚好的一趟摆渡车，</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;终于坐上了去往厦门的飞机。</p>\n","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"<p>对，没错，我们一起吹着晚风，在沙滩漫步，就像电影里那样！</p>","more":"<p>&nbsp;&nbsp;&nbsp;&nbsp;这是我们一直想要去的厦门。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;是啊，我们的厦门！</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;去厦门之前，我们一直在想，厦门是什么样的，鼓浪屿，真的娜么浪漫吗？</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;娜宝一直反复的修改攻略，而我呢就负责路上的票，给她打下手。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;就这样，我们出发了~</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;好运呢，也是一直眷恋着我们，一切都是那么刚刚好，</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;刚好的托运，</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;刚好的检票，（应为快登机了，走的快速通道。哈哈哈！）</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;接着我们又一路冲刺快速的找到我们的航班检票口，真的差点检票口就关闭了，又是刚刚好~</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;出口刚好的一趟摆渡车，</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;终于坐上了去往厦门的飞机。</p>"},{"title":"Kafka(一)","date":"2021-07-01T08:38:09.000Z","keywords":"Kafka,kafka","top":50,"image":"/images/kafka/kafka_tag_1.jpg","_content":"\nKafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。\n<!--more-->\n\n# **Apache Kafka 是一个分布式流处理平台。**\n\n## 1.0 介绍\n\nkafka 作为一个集群，运行在一台或者多台服务器上，它是通过topic对存储的流数据进行分类。每条记录中包含一个key,一个value和一个timestamp(时间戳)。\n\nKafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。\n\nkafka有四个核心的API：\n- Producer API允许一个应用程序发布一串流式的数据到一个或者多个Kafka topic。\n- Consumer API允许一个应用程序订阅一个或者多个topic,并且对发布给他们的流式数据进行处理。\n- Streams API允许一个应用程序作为一个流处理器，消费一个或者多个topic产生的输入流，然后产生一个输出流到一个或者多个topic中去，在输入输出流中进行有效的转换。\n- Connector API允许构建并运行可重用的生产者或者消费者，将Kafka Topic连接到已经存在的应用程序或者数据系统。\n![](/images/kafka/kafka-apis.png)\n\n### 1.1 相关术语\n\n#### 1.1.1 broker\n\nKafka 集群包含一个或多个服务器，服务器节点称为broker。\n\nbroker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。\n\n如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。\n\n如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。\n\n#### 1.1.2 Topic\n\n每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）\n\n类似于数据库的表名\n\n#### 1.1.3 Partition\n\ntopic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。\n\n#### 1.1.4 Producer\n\n生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。\n\n#### 1.1.5 Consumer\n\n消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。\n\n#### 1.1.6 Consumer Group\n\n每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。\n\n#### 1.1.7 Leader\n\n每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。\n\n#### 1.1.8 Follower\n\nFollower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。\n\n### 1.2 Topics和日志\nTopic 是数据主题，是数据记录发布的地方，可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费之来订阅它的数据。\n\n每一个topic，Kafka集群会维持一个分区日志。\n\n![](/images/kafka/log_anatomy.png)\n\n每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id来表示顺序，我们称为offset,offset用来唯一的标识分区中的每一条数据。\n\nkafka的性能和数据大小无关，所以长时间存储数据没什么问题。\n\n日志中的partition分区有以下几个用途。第一，当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可以有多个分区，因此可以处理无限量的数据。第二，可以作为并行的单元集。\n\n### 1.3 分布式\n\n日志的分区partition分布在Kafka集群的服务器上。每个服务器在处理数据和请求时，共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性。\n\n每个分区都有一台server作为“leader”， 0台或者多台server作为follers.leader server处理一切对partition分区的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers中的一台服务器会自动成为新的leader。每台server都会成为某些分区的leader和某些分区的follower，因此集群的负载是平衡的。\n\n### 1.4 生产者\n\n生产者可以将数据发布到所选择的topic(主题)中。生产者负责记录分配到topic中的某个partition分区中。可以使用循环的方式来简单地实现负载均衡。\n\n### 1.5 消费者\n\n消费者使用一个消费组名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的消费者实例。消费者实例可以分布在多个进程中或者多个机器上。\n\n如果所有的消费者实例在同一消费组中，消费记录会负载均衡到每一个消费者实例。\n\n如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程。\n![](/images/kafka/consumer_groups.png)\n\n如图，这个Kafka集群有两台server，四个分区和两个消费者组。消费组A有两个消费者，消费组B有四个消费者。\n\n通常情况下，每个topic都会有一些消费组，一个消费组对应一个“逻辑订阅者”。 一个消费组由许多消费者实例组成，便于扩展和容错。这就是发布和订阅的概念，只不过订阅者是一组消费者而不是单个进程。\n\n在Kafka中实现消费的方式是将日志中的分区划分到每一个消费者实例上，以便在任何时间，每个实例都是分区唯一的消费者。维护消费者组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些partition分区；如果一个实例消失，拥有的分区将被分发至剩余的实例。\n\nKafka只保证分区内记录是有序的，不保证主题中不同分区的顺序。\n\n### 1.6 Kafka作为存储系统\n\n数据写入Kafka后被写入到磁盘，并且备份以便容错，直到完全备份，Kafka才让生产者认为完成写入，即使写入失败kafka也会确保继续写入Kafka使用磁盘结构，具有很好的扩展性。\n\nKafka是一种高性能、低延迟、具备日志存储、备份和传播功能的分布式文件系统。\n\n### 1.7 Kafka用作流处理\n\nKafka流处理不仅用来读写和存储流式数据，最终目的是为了能够进行实时的流处理。在Kafka中，流处理不断地从输入的topic获取流数据，处理数据后，在不断生产数据到输出的topic中去。\n\n简单数据处理可以使用生产者和消费者的API。对于复杂的数据变换，Kafka提供了Streams　API。Stream　API允许应用做一些复杂的处理，比如将流数据聚合或者join。\n\n这一功能有助于解决以下这种应用程序面临的问题：处理无序数据，当消费端代码变更后重新处理输入，执行有状态计算等。\n\nStreams API建立在Kafka的核心之上：它使用Producer和Consumer API作为输入，使用Kafka进行有状态的存储，并在流处理实例之间使用相同的消费组机制来实现容错。\n\n### 1.8 批处理\n\nKafka将消息、存储和流处理结合起来，通过组合存储和低延迟订阅，流式应用程序可以以同样的方式处理过去和未来的数据。\n\n同样，作为流数据管道，能够订阅实时事件使得Kafka具有非常低的延迟；同时Kafka还具有可靠存储数据的特性，可用来存储重要的支付数据，或者与离线系统进行交互，系统可间歇性加载数据，也可在停机维护后再次加载数据。流处理功能使得数据可以在到达时转换数据。\n\n\n## 2.0 基本教程\n\n如果是windows平台，使用bin\\windows\\而不是bin/，并将脚本扩展名改为.bat\n\n### Step 1: 下载\n\n[下载](https://www.apache.org/dyn/closer.cgi?path=/kafka/1.0.0/kafka_2.11-1.0.0.tgz)相关版本并解压缩。\n\n> cd kafka  \n\n### Step 2: 启动服务器\n\nKafka使用[ZooKeeper](https://zookeeper.apache.org/),如果你还没有ZooKeeper服务器。\n\n> bin/zookeeper-server-start.sh config/zookeeper.properties  \n> [2021-07-2 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)\n\n开始启动Kafka服务器：\n\n> bin/kafka-server-start.sh config/server.properties\n\n### Step 3: 创建一个topic\n\n创建一个名为\"test\"的topic，有一个分区和一个副本：\n\n> bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n\n现在运行list命令来查看这个topic:\n\n> bin/kafka-topics.sh --list --zookeeper localhost:2181  \n\n> test\n\n### Step 4: 发送消息\n\nKafka自带一个命令行客户端，它从文件或标准输入中获取输入，将其作为message发送到Kafka集群。默认情况下，每行将作为单独的message发送。\n\n运行producer,然后在控制台输入一些消息已发送到服务器。\n\n> bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\n\n> This is a message\n\n### Step 5: 启动一个consumer\n\nKafka有一个命令行consumer，将消息转储到标准输出。\n\n> bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning\n\n> This is a message\n\n### Step 6: 设置多个代理集群\n\n首先，为每个代理创建一个配置文件（在windows上使用copy命令来代替）：\n\n> cp config/server.properties config/server-1.properties  \n> cp config/server.properties config/server-2.properties\n\n### Step 7: 使用Kafka Connect来导入/导出数据\n\nKafka Connect是Kafka的一个工具，它可以将数据导入和导出到Kafka。它是一种可扩展工具，通过运行connectors（连接器）， 使用自定义逻辑来实现与外部系统的交互。 在本文中，我们将看到如何使用简单的connectors来运行Kafka Connect，这些connectors 将文件中的数据导入到Kafka topic中，并从中导出数据到一个文件。\n\n首先，创建一个测试文件：\n\n> echo -e \"foo\\nbar\" > test.txt\n\n在Windows系统使用：\n\n> echo foo> test.txt  \n> echo bar>> test.txt\n\n接下来，我们将启动两个standalone（独立）运行的连接器，这意味着它们各自运行在一个单独的本地专用 进程上。 我们提供三个配置文件。首先是Kafka Connect的配置文件，包含常用的配置，如Kafka brokers连接方式和数据的序列化格式。 其余的配置文件均指定一个要创建的连接器。这些文件包括连接器的唯一名称，类的实例，以及其他连接器所需的配置。\n\n> bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties\n\n这些包含在Kafka中的示例配置文件使用您之前启动的默认本地群集配置，并创建两个连接器： 第一个是源连接器，用于从输入文件读取行，并将其输入到 Kafka topic。 第二个是接收器连接器，它从Kafka topic中读取消息，并在输出文件中生成一行。\n\n在启动过程中，你会看到一些日志消息，包括一些连接器正在实例化的指示。 一旦Kafka Connect进程启动，源连接器就开始从 test.txt 读取行并且 将它们生产到主题 connect-test 中，同时接收器连接器也开始从主题 connect-test 中读取消息， 并将它们写入文件 test.sink.txt 中。我们可以通过检查输出文件的内容来验证数据是否已通过整个pipeline进行交付：\n\n> more test.sink.txt\n\n> foo\n\n> bar\n\n数据存储在Kafka topic connect-test 中，因此我们也可以运行一个console consumer（控制台消费者）来查看 topic 中的数据（或使用custom consumer（自定义消费者）代码进行处理）：\n\n> bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic connect-test --from-beginning\n\n> {\"schema\":{\"type\":\"string\",\"optional\":false},\"payload\":\"foo\"}\n\n> {\"schema\":{\"type\":\"string\",\"optional\":false},\"payload\":\"bar\"}\n\n\n连接器一直在处理数据，所以我们可以将数据添加到文件中，并看到它在pipeline 中移动：\n\n> echo Another line>> test.txt\n\n### Step 8: 使用Kafka Streams来处理数据\n\nKafka Streams是用于构建实时关键应用程序和微服务的客户端库，输入与输出数据存储在Kafka集群中。 Kafka Streams把客户端能够轻便地编写部署标准Java和Scala应用程序的优势与Kafka服务器端集群技术相结合，使这些应用程序具有高度伸缩性、弹性、容错性、分布式等特性。\n\n## 3.0 使用案例\n\n### 3.1 消息\n\nKafka很好的替代了传统的message broker（消息代理）。Message brokers可用于各种场合（如将数据生成器与数据处理解耦，缓冲未处理的消息等）。与大多数消息系统相比，Kafka拥有更好的吞吐量、内置分区、具有复制和容错功能，这使他成为一个非常理想的大型消息处理应用。\n\n### 3.2 跟踪网站活动\n\nKafka的初始用例是将用户活动跟踪管道重建为一组实时发布-订阅源。这意味着网站活动（浏览网页、搜索或其他的用户操作）将被发布到中心topic，其中每个活动类型有一个topic。这些订阅源提供一系列用例，包括实时处理、实时监视、对加载到Hadoop或离线数据仓库系统的数据进行离线处理和报告等。\n\n### 3.3 度量\n\nKafka通常用于监控数据。这涉及到从分布式应用程序中汇总数据，然后生成可操作的集中数据源。\n\n### 3.4 日志聚合\n\n日志聚合系统通常从服务器收集物理日志文件，并将其置于一个中心系统（可能是文件服务器或HDFS）进行处理。Kafka从这些日志文件中提取信息，并将其抽象为一个更加清晰的消息流。这样可以实现更低的延迟处理且易于支持多个数据源及分布式数据的消耗。\n\n### 3.5 流处理\n\nKafka用户通过管道来处理数据，有多个阶段： 从Kafka topic中消费原始输入数据，然后聚合，修饰或通过其他方式转化为新的topic， 以供进一步消费或处理。Kafka Streams是一个轻量但功能强大的流处理库。\n\n### 3.6 采集日志\n\n[Event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)是一种应用程序设计风格，按时间来记录状态的更改。 Kafka 可以存储非常多的日志数据，为基于 event sourcing 的应用程序提供强有力的支持。\n\n### 3.7 提交日志\n\nKafka 可以从外部为分布式系统提供日志提交功能。 日志有助于记录节点和行为间的数据，采用重新同步机制可以从失败节点恢复数据。 Kafka的日志压缩 功能支持这一用法。\n\n[有关Kafka提供的保证、API和功能的更多信息，请查看相关文档。](https://kafka.apache.org/documentation/#gettingStarted)","source":"_posts/kafka-1.md","raw":"---\ntitle: Kafka(一)\ndate: 2021-07-01 16:38:09\ntags: Kafka\ncategories: 技术\nkeywords: Kafka,kafka\ntop: 50\nimage: /images/kafka/kafka_tag_1.jpg\n---\n\nKafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。\n<!--more-->\n\n# **Apache Kafka 是一个分布式流处理平台。**\n\n## 1.0 介绍\n\nkafka 作为一个集群，运行在一台或者多台服务器上，它是通过topic对存储的流数据进行分类。每条记录中包含一个key,一个value和一个timestamp(时间戳)。\n\nKafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。\n\nkafka有四个核心的API：\n- Producer API允许一个应用程序发布一串流式的数据到一个或者多个Kafka topic。\n- Consumer API允许一个应用程序订阅一个或者多个topic,并且对发布给他们的流式数据进行处理。\n- Streams API允许一个应用程序作为一个流处理器，消费一个或者多个topic产生的输入流，然后产生一个输出流到一个或者多个topic中去，在输入输出流中进行有效的转换。\n- Connector API允许构建并运行可重用的生产者或者消费者，将Kafka Topic连接到已经存在的应用程序或者数据系统。\n![](/images/kafka/kafka-apis.png)\n\n### 1.1 相关术语\n\n#### 1.1.1 broker\n\nKafka 集群包含一个或多个服务器，服务器节点称为broker。\n\nbroker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。\n\n如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。\n\n如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。\n\n#### 1.1.2 Topic\n\n每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）\n\n类似于数据库的表名\n\n#### 1.1.3 Partition\n\ntopic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。\n\n#### 1.1.4 Producer\n\n生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。\n\n#### 1.1.5 Consumer\n\n消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。\n\n#### 1.1.6 Consumer Group\n\n每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。\n\n#### 1.1.7 Leader\n\n每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。\n\n#### 1.1.8 Follower\n\nFollower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。\n\n### 1.2 Topics和日志\nTopic 是数据主题，是数据记录发布的地方，可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费之来订阅它的数据。\n\n每一个topic，Kafka集群会维持一个分区日志。\n\n![](/images/kafka/log_anatomy.png)\n\n每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id来表示顺序，我们称为offset,offset用来唯一的标识分区中的每一条数据。\n\nkafka的性能和数据大小无关，所以长时间存储数据没什么问题。\n\n日志中的partition分区有以下几个用途。第一，当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可以有多个分区，因此可以处理无限量的数据。第二，可以作为并行的单元集。\n\n### 1.3 分布式\n\n日志的分区partition分布在Kafka集群的服务器上。每个服务器在处理数据和请求时，共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性。\n\n每个分区都有一台server作为“leader”， 0台或者多台server作为follers.leader server处理一切对partition分区的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers中的一台服务器会自动成为新的leader。每台server都会成为某些分区的leader和某些分区的follower，因此集群的负载是平衡的。\n\n### 1.4 生产者\n\n生产者可以将数据发布到所选择的topic(主题)中。生产者负责记录分配到topic中的某个partition分区中。可以使用循环的方式来简单地实现负载均衡。\n\n### 1.5 消费者\n\n消费者使用一个消费组名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的消费者实例。消费者实例可以分布在多个进程中或者多个机器上。\n\n如果所有的消费者实例在同一消费组中，消费记录会负载均衡到每一个消费者实例。\n\n如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程。\n![](/images/kafka/consumer_groups.png)\n\n如图，这个Kafka集群有两台server，四个分区和两个消费者组。消费组A有两个消费者，消费组B有四个消费者。\n\n通常情况下，每个topic都会有一些消费组，一个消费组对应一个“逻辑订阅者”。 一个消费组由许多消费者实例组成，便于扩展和容错。这就是发布和订阅的概念，只不过订阅者是一组消费者而不是单个进程。\n\n在Kafka中实现消费的方式是将日志中的分区划分到每一个消费者实例上，以便在任何时间，每个实例都是分区唯一的消费者。维护消费者组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些partition分区；如果一个实例消失，拥有的分区将被分发至剩余的实例。\n\nKafka只保证分区内记录是有序的，不保证主题中不同分区的顺序。\n\n### 1.6 Kafka作为存储系统\n\n数据写入Kafka后被写入到磁盘，并且备份以便容错，直到完全备份，Kafka才让生产者认为完成写入，即使写入失败kafka也会确保继续写入Kafka使用磁盘结构，具有很好的扩展性。\n\nKafka是一种高性能、低延迟、具备日志存储、备份和传播功能的分布式文件系统。\n\n### 1.7 Kafka用作流处理\n\nKafka流处理不仅用来读写和存储流式数据，最终目的是为了能够进行实时的流处理。在Kafka中，流处理不断地从输入的topic获取流数据，处理数据后，在不断生产数据到输出的topic中去。\n\n简单数据处理可以使用生产者和消费者的API。对于复杂的数据变换，Kafka提供了Streams　API。Stream　API允许应用做一些复杂的处理，比如将流数据聚合或者join。\n\n这一功能有助于解决以下这种应用程序面临的问题：处理无序数据，当消费端代码变更后重新处理输入，执行有状态计算等。\n\nStreams API建立在Kafka的核心之上：它使用Producer和Consumer API作为输入，使用Kafka进行有状态的存储，并在流处理实例之间使用相同的消费组机制来实现容错。\n\n### 1.8 批处理\n\nKafka将消息、存储和流处理结合起来，通过组合存储和低延迟订阅，流式应用程序可以以同样的方式处理过去和未来的数据。\n\n同样，作为流数据管道，能够订阅实时事件使得Kafka具有非常低的延迟；同时Kafka还具有可靠存储数据的特性，可用来存储重要的支付数据，或者与离线系统进行交互，系统可间歇性加载数据，也可在停机维护后再次加载数据。流处理功能使得数据可以在到达时转换数据。\n\n\n## 2.0 基本教程\n\n如果是windows平台，使用bin\\windows\\而不是bin/，并将脚本扩展名改为.bat\n\n### Step 1: 下载\n\n[下载](https://www.apache.org/dyn/closer.cgi?path=/kafka/1.0.0/kafka_2.11-1.0.0.tgz)相关版本并解压缩。\n\n> cd kafka  \n\n### Step 2: 启动服务器\n\nKafka使用[ZooKeeper](https://zookeeper.apache.org/),如果你还没有ZooKeeper服务器。\n\n> bin/zookeeper-server-start.sh config/zookeeper.properties  \n> [2021-07-2 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)\n\n开始启动Kafka服务器：\n\n> bin/kafka-server-start.sh config/server.properties\n\n### Step 3: 创建一个topic\n\n创建一个名为\"test\"的topic，有一个分区和一个副本：\n\n> bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n\n现在运行list命令来查看这个topic:\n\n> bin/kafka-topics.sh --list --zookeeper localhost:2181  \n\n> test\n\n### Step 4: 发送消息\n\nKafka自带一个命令行客户端，它从文件或标准输入中获取输入，将其作为message发送到Kafka集群。默认情况下，每行将作为单独的message发送。\n\n运行producer,然后在控制台输入一些消息已发送到服务器。\n\n> bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\n\n> This is a message\n\n### Step 5: 启动一个consumer\n\nKafka有一个命令行consumer，将消息转储到标准输出。\n\n> bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning\n\n> This is a message\n\n### Step 6: 设置多个代理集群\n\n首先，为每个代理创建一个配置文件（在windows上使用copy命令来代替）：\n\n> cp config/server.properties config/server-1.properties  \n> cp config/server.properties config/server-2.properties\n\n### Step 7: 使用Kafka Connect来导入/导出数据\n\nKafka Connect是Kafka的一个工具，它可以将数据导入和导出到Kafka。它是一种可扩展工具，通过运行connectors（连接器）， 使用自定义逻辑来实现与外部系统的交互。 在本文中，我们将看到如何使用简单的connectors来运行Kafka Connect，这些connectors 将文件中的数据导入到Kafka topic中，并从中导出数据到一个文件。\n\n首先，创建一个测试文件：\n\n> echo -e \"foo\\nbar\" > test.txt\n\n在Windows系统使用：\n\n> echo foo> test.txt  \n> echo bar>> test.txt\n\n接下来，我们将启动两个standalone（独立）运行的连接器，这意味着它们各自运行在一个单独的本地专用 进程上。 我们提供三个配置文件。首先是Kafka Connect的配置文件，包含常用的配置，如Kafka brokers连接方式和数据的序列化格式。 其余的配置文件均指定一个要创建的连接器。这些文件包括连接器的唯一名称，类的实例，以及其他连接器所需的配置。\n\n> bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties\n\n这些包含在Kafka中的示例配置文件使用您之前启动的默认本地群集配置，并创建两个连接器： 第一个是源连接器，用于从输入文件读取行，并将其输入到 Kafka topic。 第二个是接收器连接器，它从Kafka topic中读取消息，并在输出文件中生成一行。\n\n在启动过程中，你会看到一些日志消息，包括一些连接器正在实例化的指示。 一旦Kafka Connect进程启动，源连接器就开始从 test.txt 读取行并且 将它们生产到主题 connect-test 中，同时接收器连接器也开始从主题 connect-test 中读取消息， 并将它们写入文件 test.sink.txt 中。我们可以通过检查输出文件的内容来验证数据是否已通过整个pipeline进行交付：\n\n> more test.sink.txt\n\n> foo\n\n> bar\n\n数据存储在Kafka topic connect-test 中，因此我们也可以运行一个console consumer（控制台消费者）来查看 topic 中的数据（或使用custom consumer（自定义消费者）代码进行处理）：\n\n> bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic connect-test --from-beginning\n\n> {\"schema\":{\"type\":\"string\",\"optional\":false},\"payload\":\"foo\"}\n\n> {\"schema\":{\"type\":\"string\",\"optional\":false},\"payload\":\"bar\"}\n\n\n连接器一直在处理数据，所以我们可以将数据添加到文件中，并看到它在pipeline 中移动：\n\n> echo Another line>> test.txt\n\n### Step 8: 使用Kafka Streams来处理数据\n\nKafka Streams是用于构建实时关键应用程序和微服务的客户端库，输入与输出数据存储在Kafka集群中。 Kafka Streams把客户端能够轻便地编写部署标准Java和Scala应用程序的优势与Kafka服务器端集群技术相结合，使这些应用程序具有高度伸缩性、弹性、容错性、分布式等特性。\n\n## 3.0 使用案例\n\n### 3.1 消息\n\nKafka很好的替代了传统的message broker（消息代理）。Message brokers可用于各种场合（如将数据生成器与数据处理解耦，缓冲未处理的消息等）。与大多数消息系统相比，Kafka拥有更好的吞吐量、内置分区、具有复制和容错功能，这使他成为一个非常理想的大型消息处理应用。\n\n### 3.2 跟踪网站活动\n\nKafka的初始用例是将用户活动跟踪管道重建为一组实时发布-订阅源。这意味着网站活动（浏览网页、搜索或其他的用户操作）将被发布到中心topic，其中每个活动类型有一个topic。这些订阅源提供一系列用例，包括实时处理、实时监视、对加载到Hadoop或离线数据仓库系统的数据进行离线处理和报告等。\n\n### 3.3 度量\n\nKafka通常用于监控数据。这涉及到从分布式应用程序中汇总数据，然后生成可操作的集中数据源。\n\n### 3.4 日志聚合\n\n日志聚合系统通常从服务器收集物理日志文件，并将其置于一个中心系统（可能是文件服务器或HDFS）进行处理。Kafka从这些日志文件中提取信息，并将其抽象为一个更加清晰的消息流。这样可以实现更低的延迟处理且易于支持多个数据源及分布式数据的消耗。\n\n### 3.5 流处理\n\nKafka用户通过管道来处理数据，有多个阶段： 从Kafka topic中消费原始输入数据，然后聚合，修饰或通过其他方式转化为新的topic， 以供进一步消费或处理。Kafka Streams是一个轻量但功能强大的流处理库。\n\n### 3.6 采集日志\n\n[Event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)是一种应用程序设计风格，按时间来记录状态的更改。 Kafka 可以存储非常多的日志数据，为基于 event sourcing 的应用程序提供强有力的支持。\n\n### 3.7 提交日志\n\nKafka 可以从外部为分布式系统提供日志提交功能。 日志有助于记录节点和行为间的数据，采用重新同步机制可以从失败节点恢复数据。 Kafka的日志压缩 功能支持这一用法。\n\n[有关Kafka提供的保证、API和功能的更多信息，请查看相关文档。](https://kafka.apache.org/documentation/#gettingStarted)","slug":"kafka-1","published":1,"updated":"2021-07-19T02:25:25.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra348wz000vzwvagday873m","content":"<p>Kafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Apache-Kafka-是一个分布式流处理平台。\"><a href=\"#Apache-Kafka-是一个分布式流处理平台。\" class=\"headerlink\" title=\"Apache Kafka 是一个分布式流处理平台。\"></a><strong>Apache Kafka 是一个分布式流处理平台。</strong></h1><h2 id=\"1-0-介绍\"><a href=\"#1-0-介绍\" class=\"headerlink\" title=\"1.0 介绍\"></a>1.0 介绍</h2><p>kafka 作为一个集群，运行在一台或者多台服务器上，它是通过topic对存储的流数据进行分类。每条记录中包含一个key,一个value和一个timestamp(时间戳)。</p>\n<p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>\n<p>kafka有四个核心的API：</p>\n<ul>\n<li>Producer API允许一个应用程序发布一串流式的数据到一个或者多个Kafka topic。</li>\n<li>Consumer API允许一个应用程序订阅一个或者多个topic,并且对发布给他们的流式数据进行处理。</li>\n<li>Streams API允许一个应用程序作为一个流处理器，消费一个或者多个topic产生的输入流，然后产生一个输出流到一个或者多个topic中去，在输入输出流中进行有效的转换。</li>\n<li>Connector API允许构建并运行可重用的生产者或者消费者，将Kafka Topic连接到已经存在的应用程序或者数据系统。<br><img src=\"/images/kafka/kafka-apis.png\"></li>\n</ul>\n<h3 id=\"1-1-相关术语\"><a href=\"#1-1-相关术语\" class=\"headerlink\" title=\"1.1 相关术语\"></a>1.1 相关术语</h3><h4 id=\"1-1-1-broker\"><a href=\"#1-1-1-broker\" class=\"headerlink\" title=\"1.1.1 broker\"></a>1.1.1 broker</h4><p>Kafka 集群包含一个或多个服务器，服务器节点称为broker。</p>\n<p>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</p>\n<p>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</p>\n<p>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p>\n<h4 id=\"1-1-2-Topic\"><a href=\"#1-1-2-Topic\" class=\"headerlink\" title=\"1.1.2 Topic\"></a>1.1.2 Topic</h4><p>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>\n<p>类似于数据库的表名</p>\n<h4 id=\"1-1-3-Partition\"><a href=\"#1-1-3-Partition\" class=\"headerlink\" title=\"1.1.3 Partition\"></a>1.1.3 Partition</h4><p>topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</p>\n<h4 id=\"1-1-4-Producer\"><a href=\"#1-1-4-Producer\" class=\"headerlink\" title=\"1.1.4 Producer\"></a>1.1.4 Producer</h4><p>生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</p>\n<h4 id=\"1-1-5-Consumer\"><a href=\"#1-1-5-Consumer\" class=\"headerlink\" title=\"1.1.5 Consumer\"></a>1.1.5 Consumer</h4><p>消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</p>\n<h4 id=\"1-1-6-Consumer-Group\"><a href=\"#1-1-6-Consumer-Group\" class=\"headerlink\" title=\"1.1.6 Consumer Group\"></a>1.1.6 Consumer Group</h4><p>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>\n<h4 id=\"1-1-7-Leader\"><a href=\"#1-1-7-Leader\" class=\"headerlink\" title=\"1.1.7 Leader\"></a>1.1.7 Leader</h4><p>每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</p>\n<h4 id=\"1-1-8-Follower\"><a href=\"#1-1-8-Follower\" class=\"headerlink\" title=\"1.1.8 Follower\"></a>1.1.8 Follower</h4><p>Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</p>\n<h3 id=\"1-2-Topics和日志\"><a href=\"#1-2-Topics和日志\" class=\"headerlink\" title=\"1.2 Topics和日志\"></a>1.2 Topics和日志</h3><p>Topic 是数据主题，是数据记录发布的地方，可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费之来订阅它的数据。</p>\n<p>每一个topic，Kafka集群会维持一个分区日志。</p>\n<p><img src=\"/images/kafka/log_anatomy.png\"></p>\n<p>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id来表示顺序，我们称为offset,offset用来唯一的标识分区中的每一条数据。</p>\n<p>kafka的性能和数据大小无关，所以长时间存储数据没什么问题。</p>\n<p>日志中的partition分区有以下几个用途。第一，当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可以有多个分区，因此可以处理无限量的数据。第二，可以作为并行的单元集。</p>\n<h3 id=\"1-3-分布式\"><a href=\"#1-3-分布式\" class=\"headerlink\" title=\"1.3 分布式\"></a>1.3 分布式</h3><p>日志的分区partition分布在Kafka集群的服务器上。每个服务器在处理数据和请求时，共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性。</p>\n<p>每个分区都有一台server作为“leader”， 0台或者多台server作为follers.leader server处理一切对partition分区的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers中的一台服务器会自动成为新的leader。每台server都会成为某些分区的leader和某些分区的follower，因此集群的负载是平衡的。</p>\n<h3 id=\"1-4-生产者\"><a href=\"#1-4-生产者\" class=\"headerlink\" title=\"1.4 生产者\"></a>1.4 生产者</h3><p>生产者可以将数据发布到所选择的topic(主题)中。生产者负责记录分配到topic中的某个partition分区中。可以使用循环的方式来简单地实现负载均衡。</p>\n<h3 id=\"1-5-消费者\"><a href=\"#1-5-消费者\" class=\"headerlink\" title=\"1.5 消费者\"></a>1.5 消费者</h3><p>消费者使用一个消费组名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的消费者实例。消费者实例可以分布在多个进程中或者多个机器上。</p>\n<p>如果所有的消费者实例在同一消费组中，消费记录会负载均衡到每一个消费者实例。</p>\n<p>如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程。<br><img src=\"/images/kafka/consumer_groups.png\"></p>\n<p>如图，这个Kafka集群有两台server，四个分区和两个消费者组。消费组A有两个消费者，消费组B有四个消费者。</p>\n<p>通常情况下，每个topic都会有一些消费组，一个消费组对应一个“逻辑订阅者”。 一个消费组由许多消费者实例组成，便于扩展和容错。这就是发布和订阅的概念，只不过订阅者是一组消费者而不是单个进程。</p>\n<p>在Kafka中实现消费的方式是将日志中的分区划分到每一个消费者实例上，以便在任何时间，每个实例都是分区唯一的消费者。维护消费者组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些partition分区；如果一个实例消失，拥有的分区将被分发至剩余的实例。</p>\n<p>Kafka只保证分区内记录是有序的，不保证主题中不同分区的顺序。</p>\n<h3 id=\"1-6-Kafka作为存储系统\"><a href=\"#1-6-Kafka作为存储系统\" class=\"headerlink\" title=\"1.6 Kafka作为存储系统\"></a>1.6 Kafka作为存储系统</h3><p>数据写入Kafka后被写入到磁盘，并且备份以便容错，直到完全备份，Kafka才让生产者认为完成写入，即使写入失败kafka也会确保继续写入Kafka使用磁盘结构，具有很好的扩展性。</p>\n<p>Kafka是一种高性能、低延迟、具备日志存储、备份和传播功能的分布式文件系统。</p>\n<h3 id=\"1-7-Kafka用作流处理\"><a href=\"#1-7-Kafka用作流处理\" class=\"headerlink\" title=\"1.7 Kafka用作流处理\"></a>1.7 Kafka用作流处理</h3><p>Kafka流处理不仅用来读写和存储流式数据，最终目的是为了能够进行实时的流处理。在Kafka中，流处理不断地从输入的topic获取流数据，处理数据后，在不断生产数据到输出的topic中去。</p>\n<p>简单数据处理可以使用生产者和消费者的API。对于复杂的数据变换，Kafka提供了Streams　API。Stream　API允许应用做一些复杂的处理，比如将流数据聚合或者join。</p>\n<p>这一功能有助于解决以下这种应用程序面临的问题：处理无序数据，当消费端代码变更后重新处理输入，执行有状态计算等。</p>\n<p>Streams API建立在Kafka的核心之上：它使用Producer和Consumer API作为输入，使用Kafka进行有状态的存储，并在流处理实例之间使用相同的消费组机制来实现容错。</p>\n<h3 id=\"1-8-批处理\"><a href=\"#1-8-批处理\" class=\"headerlink\" title=\"1.8 批处理\"></a>1.8 批处理</h3><p>Kafka将消息、存储和流处理结合起来，通过组合存储和低延迟订阅，流式应用程序可以以同样的方式处理过去和未来的数据。</p>\n<p>同样，作为流数据管道，能够订阅实时事件使得Kafka具有非常低的延迟；同时Kafka还具有可靠存储数据的特性，可用来存储重要的支付数据，或者与离线系统进行交互，系统可间歇性加载数据，也可在停机维护后再次加载数据。流处理功能使得数据可以在到达时转换数据。</p>\n<h2 id=\"2-0-基本教程\"><a href=\"#2-0-基本教程\" class=\"headerlink\" title=\"2.0 基本教程\"></a>2.0 基本教程</h2><p>如果是windows平台，使用bin\\windows\\而不是bin/，并将脚本扩展名改为.bat</p>\n<h3 id=\"Step-1-下载\"><a href=\"#Step-1-下载\" class=\"headerlink\" title=\"Step 1: 下载\"></a>Step 1: 下载</h3><p><a href=\"https://www.apache.org/dyn/closer.cgi?path=/kafka/1.0.0/kafka_2.11-1.0.0.tgz\">下载</a>相关版本并解压缩。</p>\n<blockquote>\n<p>cd kafka  </p>\n</blockquote>\n<h3 id=\"Step-2-启动服务器\"><a href=\"#Step-2-启动服务器\" class=\"headerlink\" title=\"Step 2: 启动服务器\"></a>Step 2: 启动服务器</h3><p>Kafka使用<a href=\"https://zookeeper.apache.org/\">ZooKeeper</a>,如果你还没有ZooKeeper服务器。</p>\n<blockquote>\n<p>bin/zookeeper-server-start.sh config/zookeeper.properties<br>[2021-07-2 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)</p>\n</blockquote>\n<p>开始启动Kafka服务器：</p>\n<blockquote>\n<p>bin/kafka-server-start.sh config/server.properties</p>\n</blockquote>\n<h3 id=\"Step-3-创建一个topic\"><a href=\"#Step-3-创建一个topic\" class=\"headerlink\" title=\"Step 3: 创建一个topic\"></a>Step 3: 创建一个topic</h3><p>创建一个名为”test”的topic，有一个分区和一个副本：</p>\n<blockquote>\n<p>bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test</p>\n</blockquote>\n<p>现在运行list命令来查看这个topic:</p>\n<blockquote>\n<p>bin/kafka-topics.sh –list –zookeeper localhost:2181  </p>\n</blockquote>\n<blockquote>\n<p>test</p>\n</blockquote>\n<h3 id=\"Step-4-发送消息\"><a href=\"#Step-4-发送消息\" class=\"headerlink\" title=\"Step 4: 发送消息\"></a>Step 4: 发送消息</h3><p>Kafka自带一个命令行客户端，它从文件或标准输入中获取输入，将其作为message发送到Kafka集群。默认情况下，每行将作为单独的message发送。</p>\n<p>运行producer,然后在控制台输入一些消息已发送到服务器。</p>\n<blockquote>\n<p>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test</p>\n</blockquote>\n<blockquote>\n<p>This is a message</p>\n</blockquote>\n<h3 id=\"Step-5-启动一个consumer\"><a href=\"#Step-5-启动一个consumer\" class=\"headerlink\" title=\"Step 5: 启动一个consumer\"></a>Step 5: 启动一个consumer</h3><p>Kafka有一个命令行consumer，将消息转储到标准输出。</p>\n<blockquote>\n<p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning</p>\n</blockquote>\n<blockquote>\n<p>This is a message</p>\n</blockquote>\n<h3 id=\"Step-6-设置多个代理集群\"><a href=\"#Step-6-设置多个代理集群\" class=\"headerlink\" title=\"Step 6: 设置多个代理集群\"></a>Step 6: 设置多个代理集群</h3><p>首先，为每个代理创建一个配置文件（在windows上使用copy命令来代替）：</p>\n<blockquote>\n<p>cp config/server.properties config/server-1.properties<br>cp config/server.properties config/server-2.properties</p>\n</blockquote>\n<h3 id=\"Step-7-使用Kafka-Connect来导入-导出数据\"><a href=\"#Step-7-使用Kafka-Connect来导入-导出数据\" class=\"headerlink\" title=\"Step 7: 使用Kafka Connect来导入/导出数据\"></a>Step 7: 使用Kafka Connect来导入/导出数据</h3><p>Kafka Connect是Kafka的一个工具，它可以将数据导入和导出到Kafka。它是一种可扩展工具，通过运行connectors（连接器）， 使用自定义逻辑来实现与外部系统的交互。 在本文中，我们将看到如何使用简单的connectors来运行Kafka Connect，这些connectors 将文件中的数据导入到Kafka topic中，并从中导出数据到一个文件。</p>\n<p>首先，创建一个测试文件：</p>\n<blockquote>\n<p>echo -e “foo\\nbar” &gt; test.txt</p>\n</blockquote>\n<p>在Windows系统使用：</p>\n<blockquote>\n<p>echo foo&gt; test.txt<br>echo bar&gt;&gt; test.txt</p>\n</blockquote>\n<p>接下来，我们将启动两个standalone（独立）运行的连接器，这意味着它们各自运行在一个单独的本地专用 进程上。 我们提供三个配置文件。首先是Kafka Connect的配置文件，包含常用的配置，如Kafka brokers连接方式和数据的序列化格式。 其余的配置文件均指定一个要创建的连接器。这些文件包括连接器的唯一名称，类的实例，以及其他连接器所需的配置。</p>\n<blockquote>\n<p>bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</p>\n</blockquote>\n<p>这些包含在Kafka中的示例配置文件使用您之前启动的默认本地群集配置，并创建两个连接器： 第一个是源连接器，用于从输入文件读取行，并将其输入到 Kafka topic。 第二个是接收器连接器，它从Kafka topic中读取消息，并在输出文件中生成一行。</p>\n<p>在启动过程中，你会看到一些日志消息，包括一些连接器正在实例化的指示。 一旦Kafka Connect进程启动，源连接器就开始从 test.txt 读取行并且 将它们生产到主题 connect-test 中，同时接收器连接器也开始从主题 connect-test 中读取消息， 并将它们写入文件 test.sink.txt 中。我们可以通过检查输出文件的内容来验证数据是否已通过整个pipeline进行交付：</p>\n<blockquote>\n<p>more test.sink.txt</p>\n</blockquote>\n<blockquote>\n<p>foo</p>\n</blockquote>\n<blockquote>\n<p>bar</p>\n</blockquote>\n<p>数据存储在Kafka topic connect-test 中，因此我们也可以运行一个console consumer（控制台消费者）来查看 topic 中的数据（或使用custom consumer（自定义消费者）代码进行处理）：</p>\n<blockquote>\n<p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic connect-test –from-beginning</p>\n</blockquote>\n<blockquote>\n<p>{“schema”:{“type”:”string”,”optional”:false},”payload”:”foo”}</p>\n</blockquote>\n<blockquote>\n<p>{“schema”:{“type”:”string”,”optional”:false},”payload”:”bar”}</p>\n</blockquote>\n<p>连接器一直在处理数据，所以我们可以将数据添加到文件中，并看到它在pipeline 中移动：</p>\n<blockquote>\n<p>echo Another line&gt;&gt; test.txt</p>\n</blockquote>\n<h3 id=\"Step-8-使用Kafka-Streams来处理数据\"><a href=\"#Step-8-使用Kafka-Streams来处理数据\" class=\"headerlink\" title=\"Step 8: 使用Kafka Streams来处理数据\"></a>Step 8: 使用Kafka Streams来处理数据</h3><p>Kafka Streams是用于构建实时关键应用程序和微服务的客户端库，输入与输出数据存储在Kafka集群中。 Kafka Streams把客户端能够轻便地编写部署标准Java和Scala应用程序的优势与Kafka服务器端集群技术相结合，使这些应用程序具有高度伸缩性、弹性、容错性、分布式等特性。</p>\n<h2 id=\"3-0-使用案例\"><a href=\"#3-0-使用案例\" class=\"headerlink\" title=\"3.0 使用案例\"></a>3.0 使用案例</h2><h3 id=\"3-1-消息\"><a href=\"#3-1-消息\" class=\"headerlink\" title=\"3.1 消息\"></a>3.1 消息</h3><p>Kafka很好的替代了传统的message broker（消息代理）。Message brokers可用于各种场合（如将数据生成器与数据处理解耦，缓冲未处理的消息等）。与大多数消息系统相比，Kafka拥有更好的吞吐量、内置分区、具有复制和容错功能，这使他成为一个非常理想的大型消息处理应用。</p>\n<h3 id=\"3-2-跟踪网站活动\"><a href=\"#3-2-跟踪网站活动\" class=\"headerlink\" title=\"3.2 跟踪网站活动\"></a>3.2 跟踪网站活动</h3><p>Kafka的初始用例是将用户活动跟踪管道重建为一组实时发布-订阅源。这意味着网站活动（浏览网页、搜索或其他的用户操作）将被发布到中心topic，其中每个活动类型有一个topic。这些订阅源提供一系列用例，包括实时处理、实时监视、对加载到Hadoop或离线数据仓库系统的数据进行离线处理和报告等。</p>\n<h3 id=\"3-3-度量\"><a href=\"#3-3-度量\" class=\"headerlink\" title=\"3.3 度量\"></a>3.3 度量</h3><p>Kafka通常用于监控数据。这涉及到从分布式应用程序中汇总数据，然后生成可操作的集中数据源。</p>\n<h3 id=\"3-4-日志聚合\"><a href=\"#3-4-日志聚合\" class=\"headerlink\" title=\"3.4 日志聚合\"></a>3.4 日志聚合</h3><p>日志聚合系统通常从服务器收集物理日志文件，并将其置于一个中心系统（可能是文件服务器或HDFS）进行处理。Kafka从这些日志文件中提取信息，并将其抽象为一个更加清晰的消息流。这样可以实现更低的延迟处理且易于支持多个数据源及分布式数据的消耗。</p>\n<h3 id=\"3-5-流处理\"><a href=\"#3-5-流处理\" class=\"headerlink\" title=\"3.5 流处理\"></a>3.5 流处理</h3><p>Kafka用户通过管道来处理数据，有多个阶段： 从Kafka topic中消费原始输入数据，然后聚合，修饰或通过其他方式转化为新的topic， 以供进一步消费或处理。Kafka Streams是一个轻量但功能强大的流处理库。</p>\n<h3 id=\"3-6-采集日志\"><a href=\"#3-6-采集日志\" class=\"headerlink\" title=\"3.6 采集日志\"></a>3.6 采集日志</h3><p><a href=\"https://martinfowler.com/eaaDev/EventSourcing.html\">Event sourcing</a>是一种应用程序设计风格，按时间来记录状态的更改。 Kafka 可以存储非常多的日志数据，为基于 event sourcing 的应用程序提供强有力的支持。</p>\n<h3 id=\"3-7-提交日志\"><a href=\"#3-7-提交日志\" class=\"headerlink\" title=\"3.7 提交日志\"></a>3.7 提交日志</h3><p>Kafka 可以从外部为分布式系统提供日志提交功能。 日志有助于记录节点和行为间的数据，采用重新同步机制可以从失败节点恢复数据。 Kafka的日志压缩 功能支持这一用法。</p>\n<p><a href=\"https://kafka.apache.org/documentation/#gettingStarted\">有关Kafka提供的保证、API和功能的更多信息，请查看相关文档。</a></p>\n","site":{"data":{"galleries":[{"name":"记事","cover":"/images/theme/post-image.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]},{"name":"厦门旅拍","cover":"/images/xiamen/welcome_dark_1.jpg","description":"翻开随身携带的记事本，写着许多事都是关于你。","photos":["/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg","/images/xiamen/welcome_dark_1.jpg"]}],"local_images":["/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg","/images/theme/post-image.jpg"]}},"excerpt":"<p>Kafka是一个分布式的基于发布/订阅的消息系统，有着强大的消息处理能力。</p>","more":"<h1 id=\"Apache-Kafka-是一个分布式流处理平台。\"><a href=\"#Apache-Kafka-是一个分布式流处理平台。\" class=\"headerlink\" title=\"Apache Kafka 是一个分布式流处理平台。\"></a><strong>Apache Kafka 是一个分布式流处理平台。</strong></h1><h2 id=\"1-0-介绍\"><a href=\"#1-0-介绍\" class=\"headerlink\" title=\"1.0 介绍\"></a>1.0 介绍</h2><p>kafka 作为一个集群，运行在一台或者多台服务器上，它是通过topic对存储的流数据进行分类。每条记录中包含一个key,一个value和一个timestamp(时间戳)。</p>\n<p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>\n<p>kafka有四个核心的API：</p>\n<ul>\n<li>Producer API允许一个应用程序发布一串流式的数据到一个或者多个Kafka topic。</li>\n<li>Consumer API允许一个应用程序订阅一个或者多个topic,并且对发布给他们的流式数据进行处理。</li>\n<li>Streams API允许一个应用程序作为一个流处理器，消费一个或者多个topic产生的输入流，然后产生一个输出流到一个或者多个topic中去，在输入输出流中进行有效的转换。</li>\n<li>Connector API允许构建并运行可重用的生产者或者消费者，将Kafka Topic连接到已经存在的应用程序或者数据系统。<br><img src=\"/images/kafka/kafka-apis.png\"></li>\n</ul>\n<h3 id=\"1-1-相关术语\"><a href=\"#1-1-相关术语\" class=\"headerlink\" title=\"1.1 相关术语\"></a>1.1 相关术语</h3><h4 id=\"1-1-1-broker\"><a href=\"#1-1-1-broker\" class=\"headerlink\" title=\"1.1.1 broker\"></a>1.1.1 broker</h4><p>Kafka 集群包含一个或多个服务器，服务器节点称为broker。</p>\n<p>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</p>\n<p>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</p>\n<p>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p>\n<h4 id=\"1-1-2-Topic\"><a href=\"#1-1-2-Topic\" class=\"headerlink\" title=\"1.1.2 Topic\"></a>1.1.2 Topic</h4><p>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>\n<p>类似于数据库的表名</p>\n<h4 id=\"1-1-3-Partition\"><a href=\"#1-1-3-Partition\" class=\"headerlink\" title=\"1.1.3 Partition\"></a>1.1.3 Partition</h4><p>topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</p>\n<h4 id=\"1-1-4-Producer\"><a href=\"#1-1-4-Producer\" class=\"headerlink\" title=\"1.1.4 Producer\"></a>1.1.4 Producer</h4><p>生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</p>\n<h4 id=\"1-1-5-Consumer\"><a href=\"#1-1-5-Consumer\" class=\"headerlink\" title=\"1.1.5 Consumer\"></a>1.1.5 Consumer</h4><p>消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</p>\n<h4 id=\"1-1-6-Consumer-Group\"><a href=\"#1-1-6-Consumer-Group\" class=\"headerlink\" title=\"1.1.6 Consumer Group\"></a>1.1.6 Consumer Group</h4><p>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>\n<h4 id=\"1-1-7-Leader\"><a href=\"#1-1-7-Leader\" class=\"headerlink\" title=\"1.1.7 Leader\"></a>1.1.7 Leader</h4><p>每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</p>\n<h4 id=\"1-1-8-Follower\"><a href=\"#1-1-8-Follower\" class=\"headerlink\" title=\"1.1.8 Follower\"></a>1.1.8 Follower</h4><p>Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</p>\n<h3 id=\"1-2-Topics和日志\"><a href=\"#1-2-Topics和日志\" class=\"headerlink\" title=\"1.2 Topics和日志\"></a>1.2 Topics和日志</h3><p>Topic 是数据主题，是数据记录发布的地方，可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费之来订阅它的数据。</p>\n<p>每一个topic，Kafka集群会维持一个分区日志。</p>\n<p><img src=\"/images/kafka/log_anatomy.png\"></p>\n<p>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id来表示顺序，我们称为offset,offset用来唯一的标识分区中的每一条数据。</p>\n<p>kafka的性能和数据大小无关，所以长时间存储数据没什么问题。</p>\n<p>日志中的partition分区有以下几个用途。第一，当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可以有多个分区，因此可以处理无限量的数据。第二，可以作为并行的单元集。</p>\n<h3 id=\"1-3-分布式\"><a href=\"#1-3-分布式\" class=\"headerlink\" title=\"1.3 分布式\"></a>1.3 分布式</h3><p>日志的分区partition分布在Kafka集群的服务器上。每个服务器在处理数据和请求时，共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性。</p>\n<p>每个分区都有一台server作为“leader”， 0台或者多台server作为follers.leader server处理一切对partition分区的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers中的一台服务器会自动成为新的leader。每台server都会成为某些分区的leader和某些分区的follower，因此集群的负载是平衡的。</p>\n<h3 id=\"1-4-生产者\"><a href=\"#1-4-生产者\" class=\"headerlink\" title=\"1.4 生产者\"></a>1.4 生产者</h3><p>生产者可以将数据发布到所选择的topic(主题)中。生产者负责记录分配到topic中的某个partition分区中。可以使用循环的方式来简单地实现负载均衡。</p>\n<h3 id=\"1-5-消费者\"><a href=\"#1-5-消费者\" class=\"headerlink\" title=\"1.5 消费者\"></a>1.5 消费者</h3><p>消费者使用一个消费组名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的消费者实例。消费者实例可以分布在多个进程中或者多个机器上。</p>\n<p>如果所有的消费者实例在同一消费组中，消费记录会负载均衡到每一个消费者实例。</p>\n<p>如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程。<br><img src=\"/images/kafka/consumer_groups.png\"></p>\n<p>如图，这个Kafka集群有两台server，四个分区和两个消费者组。消费组A有两个消费者，消费组B有四个消费者。</p>\n<p>通常情况下，每个topic都会有一些消费组，一个消费组对应一个“逻辑订阅者”。 一个消费组由许多消费者实例组成，便于扩展和容错。这就是发布和订阅的概念，只不过订阅者是一组消费者而不是单个进程。</p>\n<p>在Kafka中实现消费的方式是将日志中的分区划分到每一个消费者实例上，以便在任何时间，每个实例都是分区唯一的消费者。维护消费者组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些partition分区；如果一个实例消失，拥有的分区将被分发至剩余的实例。</p>\n<p>Kafka只保证分区内记录是有序的，不保证主题中不同分区的顺序。</p>\n<h3 id=\"1-6-Kafka作为存储系统\"><a href=\"#1-6-Kafka作为存储系统\" class=\"headerlink\" title=\"1.6 Kafka作为存储系统\"></a>1.6 Kafka作为存储系统</h3><p>数据写入Kafka后被写入到磁盘，并且备份以便容错，直到完全备份，Kafka才让生产者认为完成写入，即使写入失败kafka也会确保继续写入Kafka使用磁盘结构，具有很好的扩展性。</p>\n<p>Kafka是一种高性能、低延迟、具备日志存储、备份和传播功能的分布式文件系统。</p>\n<h3 id=\"1-7-Kafka用作流处理\"><a href=\"#1-7-Kafka用作流处理\" class=\"headerlink\" title=\"1.7 Kafka用作流处理\"></a>1.7 Kafka用作流处理</h3><p>Kafka流处理不仅用来读写和存储流式数据，最终目的是为了能够进行实时的流处理。在Kafka中，流处理不断地从输入的topic获取流数据，处理数据后，在不断生产数据到输出的topic中去。</p>\n<p>简单数据处理可以使用生产者和消费者的API。对于复杂的数据变换，Kafka提供了Streams　API。Stream　API允许应用做一些复杂的处理，比如将流数据聚合或者join。</p>\n<p>这一功能有助于解决以下这种应用程序面临的问题：处理无序数据，当消费端代码变更后重新处理输入，执行有状态计算等。</p>\n<p>Streams API建立在Kafka的核心之上：它使用Producer和Consumer API作为输入，使用Kafka进行有状态的存储，并在流处理实例之间使用相同的消费组机制来实现容错。</p>\n<h3 id=\"1-8-批处理\"><a href=\"#1-8-批处理\" class=\"headerlink\" title=\"1.8 批处理\"></a>1.8 批处理</h3><p>Kafka将消息、存储和流处理结合起来，通过组合存储和低延迟订阅，流式应用程序可以以同样的方式处理过去和未来的数据。</p>\n<p>同样，作为流数据管道，能够订阅实时事件使得Kafka具有非常低的延迟；同时Kafka还具有可靠存储数据的特性，可用来存储重要的支付数据，或者与离线系统进行交互，系统可间歇性加载数据，也可在停机维护后再次加载数据。流处理功能使得数据可以在到达时转换数据。</p>\n<h2 id=\"2-0-基本教程\"><a href=\"#2-0-基本教程\" class=\"headerlink\" title=\"2.0 基本教程\"></a>2.0 基本教程</h2><p>如果是windows平台，使用bin\\windows\\而不是bin/，并将脚本扩展名改为.bat</p>\n<h3 id=\"Step-1-下载\"><a href=\"#Step-1-下载\" class=\"headerlink\" title=\"Step 1: 下载\"></a>Step 1: 下载</h3><p><a href=\"https://www.apache.org/dyn/closer.cgi?path=/kafka/1.0.0/kafka_2.11-1.0.0.tgz\">下载</a>相关版本并解压缩。</p>\n<blockquote>\n<p>cd kafka  </p>\n</blockquote>\n<h3 id=\"Step-2-启动服务器\"><a href=\"#Step-2-启动服务器\" class=\"headerlink\" title=\"Step 2: 启动服务器\"></a>Step 2: 启动服务器</h3><p>Kafka使用<a href=\"https://zookeeper.apache.org/\">ZooKeeper</a>,如果你还没有ZooKeeper服务器。</p>\n<blockquote>\n<p>bin/zookeeper-server-start.sh config/zookeeper.properties<br>[2021-07-2 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)</p>\n</blockquote>\n<p>开始启动Kafka服务器：</p>\n<blockquote>\n<p>bin/kafka-server-start.sh config/server.properties</p>\n</blockquote>\n<h3 id=\"Step-3-创建一个topic\"><a href=\"#Step-3-创建一个topic\" class=\"headerlink\" title=\"Step 3: 创建一个topic\"></a>Step 3: 创建一个topic</h3><p>创建一个名为”test”的topic，有一个分区和一个副本：</p>\n<blockquote>\n<p>bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test</p>\n</blockquote>\n<p>现在运行list命令来查看这个topic:</p>\n<blockquote>\n<p>bin/kafka-topics.sh –list –zookeeper localhost:2181  </p>\n</blockquote>\n<blockquote>\n<p>test</p>\n</blockquote>\n<h3 id=\"Step-4-发送消息\"><a href=\"#Step-4-发送消息\" class=\"headerlink\" title=\"Step 4: 发送消息\"></a>Step 4: 发送消息</h3><p>Kafka自带一个命令行客户端，它从文件或标准输入中获取输入，将其作为message发送到Kafka集群。默认情况下，每行将作为单独的message发送。</p>\n<p>运行producer,然后在控制台输入一些消息已发送到服务器。</p>\n<blockquote>\n<p>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test</p>\n</blockquote>\n<blockquote>\n<p>This is a message</p>\n</blockquote>\n<h3 id=\"Step-5-启动一个consumer\"><a href=\"#Step-5-启动一个consumer\" class=\"headerlink\" title=\"Step 5: 启动一个consumer\"></a>Step 5: 启动一个consumer</h3><p>Kafka有一个命令行consumer，将消息转储到标准输出。</p>\n<blockquote>\n<p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning</p>\n</blockquote>\n<blockquote>\n<p>This is a message</p>\n</blockquote>\n<h3 id=\"Step-6-设置多个代理集群\"><a href=\"#Step-6-设置多个代理集群\" class=\"headerlink\" title=\"Step 6: 设置多个代理集群\"></a>Step 6: 设置多个代理集群</h3><p>首先，为每个代理创建一个配置文件（在windows上使用copy命令来代替）：</p>\n<blockquote>\n<p>cp config/server.properties config/server-1.properties<br>cp config/server.properties config/server-2.properties</p>\n</blockquote>\n<h3 id=\"Step-7-使用Kafka-Connect来导入-导出数据\"><a href=\"#Step-7-使用Kafka-Connect来导入-导出数据\" class=\"headerlink\" title=\"Step 7: 使用Kafka Connect来导入/导出数据\"></a>Step 7: 使用Kafka Connect来导入/导出数据</h3><p>Kafka Connect是Kafka的一个工具，它可以将数据导入和导出到Kafka。它是一种可扩展工具，通过运行connectors（连接器）， 使用自定义逻辑来实现与外部系统的交互。 在本文中，我们将看到如何使用简单的connectors来运行Kafka Connect，这些connectors 将文件中的数据导入到Kafka topic中，并从中导出数据到一个文件。</p>\n<p>首先，创建一个测试文件：</p>\n<blockquote>\n<p>echo -e “foo\\nbar” &gt; test.txt</p>\n</blockquote>\n<p>在Windows系统使用：</p>\n<blockquote>\n<p>echo foo&gt; test.txt<br>echo bar&gt;&gt; test.txt</p>\n</blockquote>\n<p>接下来，我们将启动两个standalone（独立）运行的连接器，这意味着它们各自运行在一个单独的本地专用 进程上。 我们提供三个配置文件。首先是Kafka Connect的配置文件，包含常用的配置，如Kafka brokers连接方式和数据的序列化格式。 其余的配置文件均指定一个要创建的连接器。这些文件包括连接器的唯一名称，类的实例，以及其他连接器所需的配置。</p>\n<blockquote>\n<p>bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</p>\n</blockquote>\n<p>这些包含在Kafka中的示例配置文件使用您之前启动的默认本地群集配置，并创建两个连接器： 第一个是源连接器，用于从输入文件读取行，并将其输入到 Kafka topic。 第二个是接收器连接器，它从Kafka topic中读取消息，并在输出文件中生成一行。</p>\n<p>在启动过程中，你会看到一些日志消息，包括一些连接器正在实例化的指示。 一旦Kafka Connect进程启动，源连接器就开始从 test.txt 读取行并且 将它们生产到主题 connect-test 中，同时接收器连接器也开始从主题 connect-test 中读取消息， 并将它们写入文件 test.sink.txt 中。我们可以通过检查输出文件的内容来验证数据是否已通过整个pipeline进行交付：</p>\n<blockquote>\n<p>more test.sink.txt</p>\n</blockquote>\n<blockquote>\n<p>foo</p>\n</blockquote>\n<blockquote>\n<p>bar</p>\n</blockquote>\n<p>数据存储在Kafka topic connect-test 中，因此我们也可以运行一个console consumer（控制台消费者）来查看 topic 中的数据（或使用custom consumer（自定义消费者）代码进行处理）：</p>\n<blockquote>\n<p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic connect-test –from-beginning</p>\n</blockquote>\n<blockquote>\n<p>{“schema”:{“type”:”string”,”optional”:false},”payload”:”foo”}</p>\n</blockquote>\n<blockquote>\n<p>{“schema”:{“type”:”string”,”optional”:false},”payload”:”bar”}</p>\n</blockquote>\n<p>连接器一直在处理数据，所以我们可以将数据添加到文件中，并看到它在pipeline 中移动：</p>\n<blockquote>\n<p>echo Another line&gt;&gt; test.txt</p>\n</blockquote>\n<h3 id=\"Step-8-使用Kafka-Streams来处理数据\"><a href=\"#Step-8-使用Kafka-Streams来处理数据\" class=\"headerlink\" title=\"Step 8: 使用Kafka Streams来处理数据\"></a>Step 8: 使用Kafka Streams来处理数据</h3><p>Kafka Streams是用于构建实时关键应用程序和微服务的客户端库，输入与输出数据存储在Kafka集群中。 Kafka Streams把客户端能够轻便地编写部署标准Java和Scala应用程序的优势与Kafka服务器端集群技术相结合，使这些应用程序具有高度伸缩性、弹性、容错性、分布式等特性。</p>\n<h2 id=\"3-0-使用案例\"><a href=\"#3-0-使用案例\" class=\"headerlink\" title=\"3.0 使用案例\"></a>3.0 使用案例</h2><h3 id=\"3-1-消息\"><a href=\"#3-1-消息\" class=\"headerlink\" title=\"3.1 消息\"></a>3.1 消息</h3><p>Kafka很好的替代了传统的message broker（消息代理）。Message brokers可用于各种场合（如将数据生成器与数据处理解耦，缓冲未处理的消息等）。与大多数消息系统相比，Kafka拥有更好的吞吐量、内置分区、具有复制和容错功能，这使他成为一个非常理想的大型消息处理应用。</p>\n<h3 id=\"3-2-跟踪网站活动\"><a href=\"#3-2-跟踪网站活动\" class=\"headerlink\" title=\"3.2 跟踪网站活动\"></a>3.2 跟踪网站活动</h3><p>Kafka的初始用例是将用户活动跟踪管道重建为一组实时发布-订阅源。这意味着网站活动（浏览网页、搜索或其他的用户操作）将被发布到中心topic，其中每个活动类型有一个topic。这些订阅源提供一系列用例，包括实时处理、实时监视、对加载到Hadoop或离线数据仓库系统的数据进行离线处理和报告等。</p>\n<h3 id=\"3-3-度量\"><a href=\"#3-3-度量\" class=\"headerlink\" title=\"3.3 度量\"></a>3.3 度量</h3><p>Kafka通常用于监控数据。这涉及到从分布式应用程序中汇总数据，然后生成可操作的集中数据源。</p>\n<h3 id=\"3-4-日志聚合\"><a href=\"#3-4-日志聚合\" class=\"headerlink\" title=\"3.4 日志聚合\"></a>3.4 日志聚合</h3><p>日志聚合系统通常从服务器收集物理日志文件，并将其置于一个中心系统（可能是文件服务器或HDFS）进行处理。Kafka从这些日志文件中提取信息，并将其抽象为一个更加清晰的消息流。这样可以实现更低的延迟处理且易于支持多个数据源及分布式数据的消耗。</p>\n<h3 id=\"3-5-流处理\"><a href=\"#3-5-流处理\" class=\"headerlink\" title=\"3.5 流处理\"></a>3.5 流处理</h3><p>Kafka用户通过管道来处理数据，有多个阶段： 从Kafka topic中消费原始输入数据，然后聚合，修饰或通过其他方式转化为新的topic， 以供进一步消费或处理。Kafka Streams是一个轻量但功能强大的流处理库。</p>\n<h3 id=\"3-6-采集日志\"><a href=\"#3-6-采集日志\" class=\"headerlink\" title=\"3.6 采集日志\"></a>3.6 采集日志</h3><p><a href=\"https://martinfowler.com/eaaDev/EventSourcing.html\">Event sourcing</a>是一种应用程序设计风格，按时间来记录状态的更改。 Kafka 可以存储非常多的日志数据，为基于 event sourcing 的应用程序提供强有力的支持。</p>\n<h3 id=\"3-7-提交日志\"><a href=\"#3-7-提交日志\" class=\"headerlink\" title=\"3.7 提交日志\"></a>3.7 提交日志</h3><p>Kafka 可以从外部为分布式系统提供日志提交功能。 日志有助于记录节点和行为间的数据，采用重新同步机制可以从失败节点恢复数据。 Kafka的日志压缩 功能支持这一用法。</p>\n<p><a href=\"https://kafka.apache.org/documentation/#gettingStarted\">有关Kafka提供的保证、API和功能的更多信息，请查看相关文档。</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckra348wm0009zwvadyvh9mwf","category_id":"ckra348wj0004zwvaaaaehfnh","_id":"ckra348wt000jzwvad3y64mbn"},{"post_id":"ckra348wd0001zwva4dnj4lkz","category_id":"ckra348wj0004zwvaaaaehfnh","_id":"ckra348wv000mzwva7b15gt8z"},{"post_id":"ckra348wo000bzwvahvpq0aug","category_id":"ckra348wj0004zwvaaaaehfnh","_id":"ckra348ww000ozwva6kq414f6"},{"post_id":"ckra348wp000fzwva76v1f3ko","category_id":"ckra348wj0004zwvaaaaehfnh","_id":"ckra348wx000qzwva144oddsc"},{"post_id":"ckra348wh0003zwva60lfc7bp","category_id":"ckra348wo000czwva2xjz6nwr","_id":"ckra348wx000rzwva4bws3hoy"},{"post_id":"ckra348wv000lzwva25hue54a","category_id":"ckra348wo000czwva2xjz6nwr","_id":"ckra348wx000tzwva55ad2xga"},{"post_id":"ckra348wl0007zwva1t1ca6ma","category_id":"ckra348wo000czwva2xjz6nwr","_id":"ckra348wx000uzwva6z1vbx5y"},{"post_id":"ckra348wz000vzwvagday873m","category_id":"ckra348wj0004zwvaaaaehfnh","_id":"ckra348x0000xzwvahnsp8yuy"}],"PostTag":[{"post_id":"ckra348wm0009zwvadyvh9mwf","tag_id":"ckra348wk0005zwva0f2d29qj","_id":"ckra348wp000dzwva765lbllk"},{"post_id":"ckra348wd0001zwva4dnj4lkz","tag_id":"ckra348wk0005zwva0f2d29qj","_id":"ckra348ws000hzwva5ty5f51n"},{"post_id":"ckra348wo000bzwvahvpq0aug","tag_id":"ckra348wr000gzwvacg3m52w4","_id":"ckra348wx000pzwvadjybdbku"},{"post_id":"ckra348wp000fzwva76v1f3ko","tag_id":"ckra348ww000nzwva8x30b2b2","_id":"ckra348wx000szwva9rhf9s7k"},{"post_id":"ckra348wz000vzwvagday873m","tag_id":"ckra348wk0005zwva0f2d29qj","_id":"ckra348x0000wzwva7rs62fpa"}],"Tag":[{"name":"Kafka","_id":"ckra348wk0005zwva0f2d29qj"},{"name":"sql","_id":"ckra348wr000gzwvacg3m52w4"},{"name":"nacos","_id":"ckra348ww000nzwva8x30b2b2"}]}}